plot(res.finch.sp_loc)
plot(res.finch.sp_loc)
plot(res.finch.sp_reg)
library(cati)
data(finch.ind)
oldpar <- par(no.readonly = TRUE)
####
#The function ComIndex allow to choose your own function
#(like mean, range, variance...) to calculate customize index.
require(e1071)
funct <- c("mean(x, na.rm = TRUE)", "kurtosis(x, na.rm = TRUE)",
"max(x, na.rm = TRUE) - min(x, na.rm = TRUE)")
res.finch.sp_loc <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
plot(res.finch.sp_loc)
as.listofindex(res.finch.sp_loc)
i<-as.listofindex(res.finch.sp_loc)
i[[1]]
rownames(i[[1]])
colnames(i[[1]])
i[[3]]
dim(i[[3]])
class(i[[3]])
names(i[[3]])
rownames(i[[3]])
matrix(0,4,4)
names(matrix(0,4,4))
library(cati)
data(finch.ind)
oldpar <- par(no.readonly = TRUE)
####
#The function ComIndex allow to choose your own function
#(like mean, range, variance...) to calculate customize index.
require(e1071)
funct <- c("mean(x, na.rm = TRUE)", "kurtosis(x, na.rm = TRUE)",
"max(x, na.rm = TRUE) - min(x, na.rm = TRUE)")
res.finch.sp_loc <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
res.finch.sp_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.pop",
ind.plot = ind.plot.finch, nperm = 9, print = FALSE)
####
#We can represent Standardized Effect Size (ses)
#using the function plot(as.listofindex(list1, list2, list3))
list.ind2 <- list(res.finch.sp_loc, res.finch.sp_reg)
index.list2 <- as.listofindex(list.ind2)
plot(index.list2)
plot(index.list2, type = "bytraits")
library(cati)
data(finch.ind)
oldpar <- par(no.readonly = TRUE)
####
#The function ComIndex allow to choose your own function
#(like mean, range, variance...) to calculate customize index.
require(e1071)
funct <- c("mean(x, na.rm = TRUE)", "kurtosis(x, na.rm = TRUE)",
"max(x, na.rm = TRUE) - min(x, na.rm = TRUE)")
res.finch.sp_loc <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
res.finch.sp_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.pop",
ind.plot = ind.plot.finch, nperm = 9, print = FALSE)
####
#We can represent Standardized Effect Size (ses)
#using the function plot(as.listofindex(list1, list2, list3))
list.ind2 <- list(res.finch.sp_loc, res.finch.sp_reg)
index.list2 <- as.listofindex(list.ind2)
plot(index.list2)
plot(index.list2, type = "bytraits")
?try
library(cati)
data(finch.ind)
oldpar <- par(no.readonly = TRUE)
####
#The function ComIndex allow to choose your own function
#(like mean, range, variance...) to calculate customize index.
require(e1071)
funct <- c("mean(x, na.rm = TRUE)", "kurtosis(x, na.rm = TRUE)",
"max(x, na.rm = TRUE) - min(x, na.rm = TRUE)")
res.finch.sp_loc <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
res.finch.sp_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.pop",
ind.plot = ind.plot.finch, nperm = 9, print = FALSE)
####
#We can represent Standardized Effect Size (ses)
#using the function plot(as.listofindex(list1, list2, list3))
list.ind2 <- list(res.finch.sp_loc, res.finch.sp_reg)
index.list2 <- as.listofindex(list.ind2)
plot(index.list2)
plot(index.list2, type = "bytraits")
plot(index.list2)
plot(index.list2)
library(cati)
plot(index.list2)
index.list2
attributes(index.list2)
names(index.list2)
library(cati)
library(cati)
data(finch.ind)
oldpar <- par(no.readonly = TRUE)
####
#The function ComIndex allow to choose your own function
#(like mean, range, variance...) to calculate customize index.
require(e1071)
funct <- c("mean(x, na.rm = TRUE)", "kurtosis(x, na.rm = TRUE)",
"max(x, na.rm = TRUE) - min(x, na.rm = TRUE)")
res.finch.sp_loc <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
res.finch.sp_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.pop",
ind.plot = ind.plot.finch, nperm = 9, print = FALSE)
####
#We can represent Standardized Effect Size (ses)
#using the function plot(as.listofindex(list1, list2, list3))
list.ind2 <- list(res.finch.sp_loc, res.finch.sp_reg)
index.list2 <- as.listofindex(list.ind2)
plot(index.list2)
plot(index.list2, type = "bytraits")
plot(index.list2, type = "bytraits")
plot(index.list2)
plot(index.list2, type = "bytraits")
plot(index.list2, type = "bysites")
res.finch.sp_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind",
ind.plot = ind.plot.finch,    nperm = 9, print = FALSE)
res.finch.sp_reg.pop <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.pop",
ind.plot = ind.plot.finch, nperm = 9, print = FALSE)
####
#We can represent Standardized Effect Size (ses)
#using the function plot(as.listofindex(list1, list2, list3))
list.ind2 <- list(res.finch.sp_mn2, res.finch.sp_mn2sp)
index.list2 <- as.listofindex(list.ind2)
plot(index.list2)
plot(index.list2, type = "bytraits")
####
#We can represent Standardized Effect Size (ses)
#using the function plot(as.listofindex(list1, list2, list3))
list.ind2 <- list(res.finch.sp_reg, res.finch.sp_reg.pop)
index.list2 <- as.listofindex(list.ind2)
plot(index.list2)
plot(index.list2, type = "bytraits")
plot(index.list2)
plot(index.list2, type = "bytraits")
plot(index.list2)
plot(index.list2)
plot(index.list2, type = "bytraits")
plot(index.list2, type = "bytraits")
try(axis(side = 2, seq(from = 5.5, to = 4.5+(nindex+1)*max(ntr), by = nindex+1)+(nindex+1)/2, labels = namestraits, las = 1, cex.axis = 0.7 ), silent = TRUE)
try(axis(side = 2, seq(from = 5.5, to = 4.5+(nindex+1)*max(ntr), by = nindex+1)+(nindex+1)/2, labels = namestraits, las = 1, cex.axis = 0.7 ))
nindex=6
try(axis(side = 2, seq(from = 5.5, to = 4.5+(nindex+1)*max(ntr), by = nindex+1)+(nindex+1)/2, labels = namestraits, las = 1, cex.axis = 0.7 ))
ntr=3
try(axis(side = 2, seq(from = 5.5, to = 4.5+(nindex+1)*max(ntr), by = nindex+1)+(nindex+1)/2, labels = namestraits, las = 1, cex.axis = 0.7 ))
namestraits=c("v", "b", "i")
try(axis(side = 2, seq(from = 5.5, to = 4.5+(nindex+1)*max(ntr), by = nindex+1)+(nindex+1)/2, labels = namestraits, las = 1, cex.axis = 0.7 ))
axis(side = 2, seq(from = 5.5, to = 4.5+(nindex+1)*max(ntr), by = nindex+1)+(nindex+1)/2, labels = namestraits, las = 1, cex.axis = 0.7 )
library(cati)
plot(index.list2)
plot(index.list2, type="bysites")
res.finch.ind_loc <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "local", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
res.finch.ind_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
funct <- c("tapply(x, ind.plot.finch, function(x) mean(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) kurtosis(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) max(x, na.rm = TRUE) -
min(x, na.rm = TRUE) )", "tapply(x, ind.plot.finch, function(x)
CVNND(x))"  )
##Null model local is trivial for this function
#because randomisation is within community only
res.finch.ind_loc <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "local", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
res.finch.ind_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
plot(res.finch.ind_loc)
plot(res.finch.ind_reg)
funct <- c("tapply(x, ind.plot.finch, function(x) mean(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) kurtosis(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) max(x, na.rm = TRUE) -
min(x, na.rm = TRUE) )", "tapply(x, ind.plot.finch, function(x)
CVNND(x))"  )
##Null model local is trivial for this function
#because randomisation is within community only
res.finch.ind_loc <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "local", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
res.finch.ind_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
warnings()
funct <- c("tapply(x, ind.plot.finch, function(x) mean(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) kurtosis(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) max(x, na.rm = TRUE) -
min(x, na.rm = TRUE) )")
##Null model local is trivial for this function
#because randomisation is within community only
res.finch.ind_loc <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "local", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
res.finch.ind_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
plot(res.finch.ind_loc)
res.finch.ind_loc
res.finch.ind_loc$obs
res.finch.ind_loc$null
data(finch.ind)
oldpar <- par(no.readonly = TRUE)
####
#The function ComIndex allow to choose your own function
#(like mean, range, variance...) to calculate customize index.
require(e1071)
funct <- c("mean(x, na.rm = TRUE)", "kurtosis(x, na.rm = TRUE)",
"max(x, na.rm = TRUE) - min(x, na.rm = TRUE)")
\dontrun{
res.finch.sp_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind",
ind.plot = ind.plot.finch,    nperm = 9, print = FALSE)
res.finch.sp_reg.pop <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.pop",
ind.plot = ind.plot.finch, nperm = 9, print = FALSE)
####
#We can represent Standardized Effect Size (ses)
#using the function plot(as.listofindex(list1, list2, list3))
list.ind2 <- list(res.finch.sp_reg, res.finch.sp_reg.pop)
index.list2 <- as.listofindex(list.ind2)
plot(index.list2, type = "bytraits")
data(finch.ind)
oldpar <- par(no.readonly = TRUE)
####
#The function ComIndex allow to choose your own function
#(like mean, range, variance...) to calculate customize index.
require(e1071)
funct <- c("mean(x, na.rm = TRUE)", "kurtosis(x, na.rm = TRUE)",
"max(x, na.rm = TRUE) - min(x, na.rm = TRUE)")
\dontrun{
res.finch.sp_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind",
ind.plot = ind.plot.finch,    nperm = 9, print = FALSE)
res.finch.sp_reg.pop <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.pop",
ind.plot = ind.plot.finch, nperm = 9, print = FALSE)
####
#We can represent Standardized Effect Size (ses)
#using the function plot(as.listofindex(list1, list2, list3))
list.ind2 <- list(res.finch.sp_reg, res.finch.sp_reg.pop)
index.list2 <- as.listofindex(list.ind2)
plot(index.list2, type = "bysites")
plot(index.list2, type = "bysites")
plot(index.list2, type = "bysites")
ntr <- c(ntr,dim(as.matrix(index.list2[[i]]))[2])
ntr <- c(dim(as.matrix(index.list2[[i]]))[2])
dim(as.matrix(index.list2[[1]]))[2]
dim(as.matrix(index.list2[[2]]))[2]
dim(as.matrix(index.list2[[1]]))[1]
library(cati)
plot(index.list2, type = "bytraits")
plot(index.list2, type = "bytraits")
plot(index.list2, type = "bysites")
plot(index.list2, type = "bysites")
plot(index.list2, type = "bysites")
library(cati)
funct <- c("tapply(x, ind.plot.finch, function(x) mean(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) kurtosis(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) max(x, na.rm = TRUE) -
min(x, na.rm = TRUE) )" )
##Null model local is trivial for this function
#because randomisation is within community only
res.finch.ind_loc <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "local", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
res.finch.ind_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
plot(res.finch.ind_reg, type="bysites")
library(cati)
plot(res.finch.ind_reg, type="bytraits")
plot(res.finch.ind_loc, type="bytraits")
plot(res.finch.ind_loc, type="bytraits")
plot(res.finch.ind_loc, type="bytraits")
plot(res.finch.ind_loc, type="bysites")
res.finch.ind_reg
res.finch.ind_reg$obs
plot(res.finch.ind_reg)
plot(res.finch.ind_reg)
plot(res.finch.ind_reg)
names(res.finch.ind_reg[[1]])
names(as.listofindex(res.finch.ind_reg)[[1]])
data(finch.ind)
oldpar <- par(no.readonly = TRUE)
####
#The function ComIndex allow to choose your own function
#(like mean, range, variance...) to calculate customize index.
require(e1071)
funct <- c("mean(x, na.rm = TRUE)", "kurtosis(x, na.rm = TRUE)",
"max(x, na.rm = TRUE) - min(x, na.rm = TRUE)")
\dontrun{
res.finch.sp_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind",
ind.plot = ind.plot.finch,    nperm = 9, print = FALSE)
res.finch.sp_reg.pop <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.pop",
ind.plot = ind.plot.finch, nperm = 9, print = FALSE)
####
#We can represent Standardized Effect Size (ses)
#using the function plot(as.listofindex(list1, list2, list3))
list.ind2 <- list(res.finch.sp_reg, res.finch.sp_reg.pop)
index.list2 <- as.listofindex(list.ind2)
####
#This allows to calcul index per site
#for example using "tapply(x, sites, mean)".
funct <- c("tapply(x, ind.plot.finch, function(x) mean(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) kurtosis(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) max(x, na.rm = TRUE) -
min(x, na.rm = TRUE) )" )
##Null model local is trivial for this function
#because randomisation is within community only
res.finch.ind_loc <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "local", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
res.finch.ind_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
res.finch.ind_reg
summary(res.finch.ind_reg)
plot(res.finch.ind_reg)
plot(res.finch.ind_reg)
library(cati)
library(cati)
plot(res.finch.ind_reg)
library(cati)
library(cati)
plot(res.finch.ind_reg)
data(finch.ind)
oldpar <- par(no.readonly = TRUE)
####
#The function ComIndex allow to choose your own function
#(like mean, range, variance...) to calculate customize index.
require(e1071)
funct <- c("mean(x, na.rm = TRUE)", "kurtosis(x, na.rm = TRUE)",
"max(x, na.rm = TRUE) - min(x, na.rm = TRUE)")
\dontrun{
res.finch.sp_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind",
ind.plot = ind.plot.finch,    nperm = 9, print = FALSE)
res.finch.sp_reg.pop <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.pop",
ind.plot = ind.plot.finch, nperm = 9, print = FALSE)
####
#We can represent Standardized Effect Size (ses)
#using the function plot(as.listofindex(list1, list2, list3))
list.ind2 <- list(res.finch.sp_reg, res.finch.sp_reg.pop)
index.list2 <- as.listofindex(list.ind2)
####
#This allows to calcul index per site
#for example using "tapply(x, sites, mean)".
funct <- c("tapply(x, ind.plot.finch, function(x) mean(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) kurtosis(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) max(x, na.rm = TRUE) -
min(x, na.rm = TRUE) )" )
##Null model local is trivial for this function
#because randomisation is within community only
res.finch.ind_loc <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "local", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
res.finch.ind_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
plot(res.finch.ind_loc)
plot(res.finch.ind_reg)
x<-res.finch.ind_reg; type = "normal"; col.index = c("red";"purple";"olivedrab3"); add.conf = TRUE; color.cond = TRUE; val.quant = c(0.025;0.975); grid.v = TRUE; grid.h = TRUE; xlim = NULL; ylim = NULL; cex.text = 0.8; plot.ask = FALSE; srt.text = 90; alpha=0.4
x<-res.finch.ind_reg; type = "normal"; col.index = c("red","purple","olivedrab3"); add.conf = TRUE; color.cond = TRUE; val.quant = c(0.025;0.975); grid.v = TRUE; grid.h = TRUE; xlim = NULL; ylim = NULL; cex.text = 0.8; plot.ask = FALSE; srt.text = 90; alpha=0.4
x<-res.finch.ind_reg; type = "normal"; col.index = c("red","purple","olivedrab3"); add.conf = TRUE; color.cond = TRUE; val.quant = c(0.025,0.975); grid.v = TRUE; grid.h = TRUE; xlim = NULL; ylim = NULL; cex.text = 0.8; plot.ask = FALSE; srt.text = 90; alpha=0.4
if (!inherits(x, "listofindex")) {
if (inherits(x[[1]], "Tstats") | inherits(x[[2]], "ComIndex")  | inherits(x[[3]], "ComIndexMulti")) {
x <- as.listofindex(x)
}
else{stop("x must be a list of objects of class Tstats, ComIndex, ComIndexMulti or listofindex")}
}
#function from package adegenet (function transp)
transpa<-function (col, alpha = 0.5) {
res <- apply(col2rgb(col), 2, function(c) rgb(c[1]/255, c[2]/255, c[3]/255, alpha))
return(res)
}
index.list <- x
oldpar <- par(no.readonly = TRUE)
par(ask = plot.ask)
namesindex.all <- names(index.list)
nindex <- length(names(index.list))/2
namesindex <- names(index.list)[seq(1,nindex*2, by = 2)]
if(is.null(colnames(index.list[[1]]))){
namestraits <-names(index.list[[1]])
namescommunity <- "region"
} else {
namestraits <- colnames(index.list[[1]])
namescommunity <- rownames(index.list[[1]])
}
if (is.null(namescommunity)) {warning("rownames of index.list[[1]] is empty so names of plots cannot be plot")}
if (is.null(namestraits)) {warning("colnames of index.list[[1]] is empty so names of traits cannot be plot")}
ncom <- c()
ntr <- c()
for(i in seq(1, 2*nindex, by = 2)){
ncom <- c(ncom,dim(as.matrix(index.list[[i]]))[2])
ntr <- c(ntr,dim(as.matrix(index.list[[i]]))[1])
}
if(namescommunity == "region")){
ncom <- 1
ntr <- length(namestraits)
}
if (is.null(ncom)) {ncom <- dim(as.matrix(index.list[[1]]))[2]}
if (is.null(ntr)) {ntr <- dim(as.matrix(index.list[[1]]))[1]}
if (is.null(ncom)) {ncom <- 1}
if (is.null(ntr)) {ntr <- 1}
if (length(col.index)<nindex){
col.index <- funky.col(nindex)
}
#________________________________________
#calculation of standardised effect size
res <- list()
for (i in seq(1,nindex*2, by = 2)){
res[[eval(namesindex.all[i])]] <- ses(obs = index.list[[i]], nullmodel = index.list[[i+1]], val.quant = val.quant)
}
res <- lapply(res, function(x) lapply(x, as.matrix)   )
nfactor <- c()
for(i in 1:nindex){
if (ntr[i]>1) nfactor <- c(nfactor, dim(as.matrix(res[[eval(namesindex[i])]]$ses))[1])
if (ntr[i] == 1) nfactor <- c(nfactor, length(res[[eval(namesindex[i])]]$ses))
}
bysite <- FALSE
if(type == "bysites"){
type <- "bytraits"
bysite <- TRUE
}
ntr <- c(ntr,dim(as.matrix(index.list[[i]]))[1])
ntr
ncom <- c()
ntr <- c()
for(i in seq(1, 2*nindex, by = 2)){
ncom <- c(ncom,dim(as.matrix(index.list[[i]]))[2])
ntr <- c(ntr,dim(as.matrix(index.list[[i]]))[1])
}
2*nindex
as.matrix(index.list[[i]])
as.matrix(index.list[[1]])
as.matrix(index.list[[2]])
as.matrix(index.list[[3]])
as.matrix(index.list[[10]])
as.matrix(index.list[[12]])
as.matrix(index.list[[9]])
ncom <- c()
ntr <- c()
for(i in seq(1, 2*nindex, by = 2)){
ncom <- c(ncom,dim(as.matrix(index.list[[i]]))[2])
ntr <- c(ntr,dim(as.matrix(index.list[[i]]))[1])
}
dim(as.matrix(index.list[[1]]))[2]
dim(as.matrix(index.list[[2]]))[2]
dim(as.matrix(index.list[[3]]))[2]
dim(as.matrix(index.list[[3]]))[1]
data(finch.ind)
oldpar <- par(no.readonly = TRUE)
####
#The function ComIndex allow to choose your own function
#(like mean, range, variance...) to calculate customize index.
require(e1071)
funct <- c("mean(x, na.rm = TRUE)", "kurtosis(x, na.rm = TRUE)",
"max(x, na.rm = TRUE) - min(x, na.rm = TRUE)")
\dontrun{
res.finch.sp_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind",
ind.plot = ind.plot.finch,    nperm = 9, print = FALSE)
res.finch.sp_reg.pop <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.pop",
ind.plot = ind.plot.finch, nperm = 9, print = FALSE)
####
#We can represent Standardized Effect Size (ses)
#using the function plot(as.listofindex(list1, list2, list3))
list.ind2 <- list(res.finch.sp_reg, res.finch.sp_reg.pop)
index.list2 <- as.listofindex(list.ind2)
####
#This allows to calcul index per site
#for example using "tapply(x, sites, mean)".
funct <- c("tapply(x, ind.plot.finch, function(x) mean(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) kurtosis(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) max(x, na.rm = TRUE) -
min(x, na.rm = TRUE) )" )
##Null model local is trivial for this function
#because randomisation is within community only
res.finch.ind_loc <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "local", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
res.finch.ind_reg <- ComIndex(traits = traits.finch, index = funct,
sp = sp.finch, nullmodels = "regional.ind", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
library(cati)
plot(res.finch.ind_loc)
plot(res.finch.ind_reg)
plot(res.finch.ind_loc)
ses(res.finch.ind_loc)
ses(as.listofindex(res.finch.ind_loc))
