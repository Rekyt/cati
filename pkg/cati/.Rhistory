as.listofindex(res.finch)
ses(as.listofindex(res.finch))
data(finch.ind)
#Define the function s to calculate
funct<-c("mean(x, na.rm = TRUE)", "kurtosis(x, na.rm = TRUE)",
"max(x, na.rm = TRUE) - min(x, na.rm = TRUE)" )
#Test against the null model regional.ind
res.finch.sp_regional.ind<-ComIndex(traits = Traits.finch, index = funct, sp = sp.finch,
nullmodels = "regional.ind", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
#Test against the null model regional.pop
#Individuals values are transformed in populational values
res.finch.sp_regional.pop<-ComIndex(traits = Traits.finch, index = funct, sp = sp.finch,
nullmodels = "regional.pop", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
#We can calculate index with or without intraspecific variance.
#calculate  of means by population (name_sp_site is a name of a population)
#determine the site for each population (sites_bypop)
name_sp_sites = paste(sp.finch, ind.plot.finch,sep = "_")
traits.by.pop<-apply(traits.finch, 2 ,
function (x) tapply(x, name_sp_sites, mean , na.rm = TRUE))
sites_bypop<-lapply(strsplit(paste(rownames(traits.by.pop), sep = "_"), split = "_"),
function(x) x[3])
#New list of function "funct"
funct.1<-c("tapply(x, ind.plot.finch, function(x) mean(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) kurtosis(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) max(x, na.rm = TRUE)-min(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) CVNND(x))" )
fact<-unlist(sites_bypop)
funct.2<-c("tapply(x, fact, function(x) mean(x, na.rm = TRUE))",
"tapply(x, fact, function(x) kurtosis(x, na.rm = TRUE))",
"tapply(x, fact, function(x) max(x, na.rm = TRUE)-min(x, na.rm = TRUE))",
"tapply(x, fact, function(x) CVNND(x))")
res.finch.withIV<-ComIndex(traits = Traits.finch, index = funct.1,
sp = sp.finch, nullmodels = "regional.ind",
ind.plot = ind.plot.finch, nperm = 9, print = FALSE)
res.finch.withoutIV<-ComIndex(traits = Traits.finch, index = funct.2,
sp = sp.finch, nullmodels = "regional.pop",
ind.plot = ind.plot.finch, nperm = 9, print = FALSE)
#ComIndex class are associated to S3 methods plot, print and summary.
res.finch.withIV
summary(res.finch.withIV)
plot(res.finch.withIV)
plot(res.finch.withoutIV)
plot(as.listofindex(list(res.finch.withIV, res.finch.withoutIV)))
data(finch.ind)
#Define the function s to calculate
funct<-c("mean(x, na.rm = TRUE)", "kurtosis(x, na.rm = TRUE)",
"max(x, na.rm = TRUE) - min(x, na.rm = TRUE)" )
#Test against the null model regional.ind
res.finch.sp_regional.ind<-ComIndex(traits = traits.finch, index = funct, sp = sp.finch,
nullmodels = "regional.ind", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
#Test against the null model regional.pop
#Individuals values are transformed in populational values
res.finch.sp_regional.pop<-ComIndex(traits = traits.finch, index = funct, sp = sp.finch,
nullmodels = "regional.pop", ind.plot = ind.plot.finch,
nperm = 9, print = FALSE)
#We can calculate index with or without intraspecific variance.
#calculate  of means by population (name_sp_site is a name of a population)
#determine the site for each population (sites_bypop)
name_sp_sites = paste(sp.finch, ind.plot.finch,sep = "_")
traits.by.pop<-apply(traits.finch, 2 ,
function (x) tapply(x, name_sp_sites, mean , na.rm = TRUE))
sites_bypop<-lapply(strsplit(paste(rownames(traits.by.pop), sep = "_"), split = "_"),
function(x) x[3])
#New list of function "funct"
funct.1<-c("tapply(x, ind.plot.finch, function(x) mean(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) kurtosis(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) max(x, na.rm = TRUE)-min(x, na.rm = TRUE))",
"tapply(x, ind.plot.finch, function(x) CVNND(x))" )
fact<-unlist(sites_bypop)
funct.2<-c("tapply(x, fact, function(x) mean(x, na.rm = TRUE))",
"tapply(x, fact, function(x) kurtosis(x, na.rm = TRUE))",
"tapply(x, fact, function(x) max(x, na.rm = TRUE)-min(x, na.rm = TRUE))",
"tapply(x, fact, function(x) CVNND(x))")
res.finch.withIV<-ComIndex(traits = traits.finch, index = funct.1,
sp = sp.finch, nullmodels = "regional.ind",
ind.plot = ind.plot.finch, nperm = 9, print = FALSE)
res.finch.withoutIV<-ComIndex(traits = traits.finch, index = funct.2,
sp = sp.finch, nullmodels = "regional.pop",
ind.plot = ind.plot.finch, nperm = 9, print = FALSE)
#ComIndex class are associated to S3 methods plot, print and summary.
res.finch.withIV
summary(res.finch.withIV)
plot(res.finch.withIV)
plot(res.finch.withoutIV)
plot(as.listofindex(list(res.finch.withIV, res.finch.withoutIV)))
?install.packages
library(cati)
library(cati)
library(cati)
data(finch.ind)
Then, calculate the T-statistics on Darwin finchesâ€™ data and plot the result.
res <- Tstats(traits.finch, ind.plot.finch, sp.finch)
res
plot(res)
>>>>>>> d0b211331074d6462608d116c3317bf39e66e950
library(cati)
??fitContinuous
??FitContinuous
install.packages("geiger")
??FitContinuous
library(cati)
data(finch.ind)
res.finch <- Tstats(traits.finch, ind.plot = ind.plot.finch,
sp = sp.finch, nperm = 9, print = FALSE)
res.finch
dim(unlist(SE.reg.pool))
dim(unlist(NA))
library(cati)
data(finch.ind)
res.finch <- Tstats(traits.finch, ind.plot = ind.plot.finch,
sp = sp.finch, nperm = 9, print = FALSE)
res.finch
### Function to calculation Tstats
Tstats <- function(traits, ind.plot, sp, SE = 0, reg.pool = NULL, SE.reg.pool = NULL, nperm = 99, printprogress = TRUE){
#6 variances: I: individual, P: population, C: community, R: region
#IP; IC; IR; PC; PR; CR
#traits is the matrix of individual traits, ind.plot is the name of the plot in which the individual is (factor type), and sp is the species name of each individual
names_sp_ind.plot <- as.factor(paste(sp, ind.plot, sep = "@"))
Tplosp <- unlist(strsplit(levels(names_sp_ind.plot), split = "@"))[2*(1:nlevels(names_sp_ind.plot))]
names(Tplosp) <- levels(names_sp_ind.plot)
#Tplosp is the plot in wich the population is
if(!is.null(nperm)){
if (nperm == 0) {nperm = NULL}
}
########################################
####	calculation of observed values	####
########################################
#________________________________________
#Objects creation
mean_IP <- matrix(nrow = nlevels(names_sp_ind.plot), ncol = ncol(traits))
rownames(mean_IP) = levels(names_sp_ind.plot)
mean_PC <- matrix(nrow = nlevels(ind.plot), ncol = ncol(traits))
var_IP <- matrix(nrow = nlevels(names_sp_ind.plot), ncol = ncol(traits))
var_PC <- matrix(nrow = nlevels(ind.plot), ncol = ncol(traits))
var_CR <- vector()
var_IC <- matrix(nrow = nlevels(ind.plot), ncol = ncol(traits))
var_PR <- vector()
var_IR <- vector()
T_IP.IC <- matrix(nrow = nlevels(ind.plot), ncol = ncol(traits))
T_IC.IR <- matrix(nrow = nlevels(ind.plot), ncol = ncol(traits))
T_PC.PR <- matrix(nrow = nlevels(ind.plot), ncol = ncol(traits))
for (t in 1: ncol(traits)){
mean_IP[,t] <- tapply(traits[,t], names_sp_ind.plot  ,mean, na.rm = T)
mean_PC[,t] <- tapply(mean_IP[,t], Tplosp , mean, na.rm = T)
var_IP[,t] <- tapply(traits[,t], names_sp_ind.plot, var, na.rm = T)
var_PC[,t] <- tapply(mean_IP[,t], Tplosp  ,var, na.rm = T)
var_CR[t] <- var(mean_PC[,t], na.rm = T)
var_IC[,t] <- tapply(traits[,t], ind.plot  ,var, na.rm = T)
var_PR[t] <- var(as.vector(mean_IP[,t]), na.rm = T)
var_IR[t] <- var(traits[,t], na.rm = T)
for(s in 1 : nlevels(ind.plot)){
T_IP.IC[s,t] <- mean(var_IP[grepl(levels(ind.plot)[s],Tplosp),t], na.rm = T)/var_IC[s,t]
T_IC.IR[s,t] <- var_IC[s,t]/var_IR[t]
T_PC.PR[s,t] <- var_PC[s,t]/var_PR[t]
}
}
#________________________________________
#########################################
#### 	  Creating null models  	 ####
#########################################
#null model 1 = local
#null model 2 = regional.ind
#null model 2.sp = regional.pop
if (is.numeric(nperm)){
var_IP_nm1 <- array(dim = c(nperm,ncol(traits),nrow = length(Tplosp)))
var_PC_nm2sp <- array(dim = c(nperm,ncol(traits),nlevels(ind.plot)))
var_IC_nm1 <- array(dim = c(nperm,ncol(traits),nlevels(ind.plot)))
var_IC_nm2 <- array(dim = c(nperm,ncol(traits),nlevels(ind.plot)))
var_PR_nm2sp <- array(dim = c(nperm,ncol(traits)))
var_IR_nm2 <- array(dim = c(nperm,ncol(traits)))
mean_IP_nm2sp <- array(dim = c(nperm,ncol(traits),length(Tplosp)))
mean_PC_nm2sp <- array(dim = c(nperm,ncol(traits),nlevels(ind.plot)))
traits.nm1 <- list()
traits.nm2 <- list()
traits.nm2sp <- list()
T_IP.IC_nm1 <- array(dim = c(nperm,ncol(traits),nlevels(ind.plot)))
T_IC.IR_nm2 <- array(dim = c(nperm,ncol(traits),nlevels(ind.plot)))
T_PC.PR_nm2sp <- array(dim = c(nperm,ncol(traits),nlevels(ind.plot)))
#########################################
#### 	  Creating regional pools  	 ####
#########################################
if(is.null(SE.reg.pool)){
SE.reg.pool <- SE
}
#If the regional pool is the same for all communitiers:
#create a list of regional pool (one regional pool by community)
if (is.null(reg.pool)) {
reg.pool <- rep(list(traits), nlevels(ind.plot))
SE.reg.pool <- rep(list(SE.reg.pool), nlevels(ind.plot))
}
if (is.data.frame(reg.pool) | is.matrix(reg.pool) ) {
reg.pool <- rep(list(reg.pool), nlevels(ind.plot))
SE.reg.pool <- rep(list(SE.reg.pool), nlevels(ind.plot))
}
if(length(reg.pool) != nlevels(ind.plot)){
stop("reg.pool need to be either a matrix or a list of length equal to the number of communities")
}
#________________________________________
# Warnings and stop about standard errors parameter
if (length(SE) != ncol(traits) & length(SE) != 1) {
stop("The vector SE need to have a length of one or equal to the number of traits")
}
if(!is.null(SE.reg.pool) & !is.null(reg.pool)){
if (dim(unlist(SE.reg.pool)) != dim(unlist(reg.pool))) {
stop("The vector SE.reg.pool need to have the same dimension as reg.pool")
}
}
#########################################
####   End creating regional pools   ####
#########################################
# Creation of three null models
if (printprogress == T){print("creating null models")}
#________________________________________
# Null model 1: Sample individual traits values within communities
for (t in 1: ncol(traits)){
traits.nm1[[t]] <- list()
for(s in 1:  nlevels(ind.plot)) {
traits.nm1[[t]][[s]] <- list()
for(i in 1:nperm){
# Take measurement standard error into account
trait.intern <- traits[,t]
if (SE != 0) {
trait.intern <- rnorm( length(trait.intern), mean = trait.intern, sd = SE)
}
# Sample individual traits values within communities
if (length(traits[ind.plot == levels(ind.plot)[s], t])  !=  1) {
perm_ind.plot1 <- sample(trait.intern[ind.plot == levels(ind.plot)[s]], table(ind.plot)[s])
traits.nm1[[t]][[s]][[i]] <- perm_ind.plot1
}
else {traits.nm1[[t]][[s]][[i]] <- "NA"}
}
}
if (printprogress == T){print(paste(round(t/ncol(traits)/3*100,2),"%")) } else {}
}
#________________________________________
# Null model 2: Sample individual traits values in the region
for (t in 1: ncol(traits)){
traits.nm2[[t]] <- list()
for(s in 1:  nlevels(ind.plot)) {
traits.nm2[[t]][[s]] <- list()
for(i in 1:nperm){
# Take measurement standard error into account
trait.intern <- reg.pool[[s]][, t]
SE.reg.pool <- SE.reg.pool[[s]][, t]
if (SE != 0) {
trait.intern <- rnorm(length(trait.intern), mean = trait.intern, sd = SE.reg.pool)
}
# Sample individual traits values in the region
perm_ind.plot2 <- sample(trait.intern, table(ind.plot)[s])
traits.nm2[[t]][[s]][[i]] <- perm_ind.plot2
}
}
if (printprogress == T){print(paste(round(33.3+t/ncol(traits)/3*100, 2),"%"))} else {}
}
#________________________________________
# Null model 2sp: Sample populationnal traits values in the region
traits_by_sp <- apply(traits, 2, function(x) tapply(x, names_sp_ind.plot, mean))
traits_by_pop <- traits_by_sp[match(names_sp_ind.plot, rownames(traits_by_sp)), ]
#traits_by_sp <- aggregate(traits, by = list(names_sp_ind.plot), mean, na.rm = T)[,-1]
for (t in 1: ncol(traits)){
traits.nm2sp[[t]] <- list()
for(s in 1:  nlevels(ind.plot)){
traits.nm2sp[[t]][[s]] <- list()
for(i in 1:nperm){
########################## Not trivial to use measurement error at the individual level for calculation of populationnal mean
# Take measurement standard error into account
#trait.intern <- traits_by_pop[,t]
#if (SE != 0) {
#	trait.intern <- rnorm(length(trait.intern), mean = trait.intern, sd = SE)
#}
# Sample populationnal traits values in the region
perm_ind.plot2sp <- sample(traits_by_pop[,t], table(ind.plot)[s])
traits.nm2sp[[t]][[s]][[i]] <- perm_ind.plot2sp
}
}
if (printprogress == T){print(paste(round(66.6+t/ncol(traits)/3*100, 2),"%"))} else {}
}
#________________________________________
#########################################
#### calculation of Tstats on null models ####
#########################################
if (printprogress == T){print("calculation of Tstats using null models")}
yy <- length(names_sp_ind.plot)
for (t in 1: ncol(traits)){
for(i in 1:nperm){
mean_IP_nm2sp[i,t, ] <- tapply(unlist(traits.nm2sp[[t]])[(1+(i-1)*yy) : (i*yy)], names_sp_ind.plot  ,function(x) mean(x, na.rm = T))
mean_PC_nm2sp[i,t, ] <- tapply(mean_IP_nm2sp[i,t, ], Tplosp, mean, na.rm = T)
}
if (printprogress == T){print(paste(round(t/ncol(traits)/3*100, 2),"%"))} else {}
}
for (t in 1: ncol(traits)){
for(i in 1:nperm){
var_IP_nm1[i,t, ] <- tapply(unlist(traits.nm1[[t]])[(1+(i-1)*yy) : (i*yy)], names_sp_ind.plot  ,function(x) var(x, na.rm = T))
var_PC_nm2sp[i,t, ] <- tapply(mean_IP_nm2sp[i,t, ], Tplosp  ,var, na.rm = T)
var_IC_nm1[i,t, ] <- tapply(unlist(traits.nm1[[t]])[(1+(i-1)*yy) : (i*yy)], ind.plot  ,function(x) var(x, na.rm = T))
var_IC_nm2[i,t, ] <- tapply(unlist(traits.nm2[[t]])[(1+(i-1)*yy) : (i*yy)], ind.plot  ,function(x) var(x, na.rm = T))
var_PR_nm2sp[i,t] <- var(as.vector(mean_IP_nm2sp[i,t, ]), na.rm = T)
var_IR_nm2[i,t] <- var(unlist(traits.nm2[[t]])[(1+(i-1)*yy) : (i*yy)], na.rm = T)
}
if (printprogress == T){print(paste(round(33.3+t/ncol(traits)/3*100, 2),"%"))} else {}
}
for (t in 1: ncol(traits)){
for(i in 1:nperm){
for(s in 1 : nlevels(ind.plot)){
T_IP.IC_nm1[i,t,s] <- mean(var_IP_nm1[i,t,grepl(levels(ind.plot)[s],Tplosp)], na.rm = T)/var_IC_nm1[i,t,s]
T_IC.IR_nm2[i,t,s] <- var_IC_nm2[i,t,s]/var_IR_nm2[i,t]
T_PC.PR_nm2sp[i,t,s] <- var_PC_nm2sp[i,t,s]/var_PR_nm2sp[i,t]
}
}
if (printprogress == T){print(paste(round(66.6+t/ncol(traits)/3*100, 2),"%"))} else {}
}
}#end of calculation of Tstats using null models
colnames(T_IP.IC) <- colnames(traits)
colnames(T_IC.IR) <- colnames(traits)
colnames(T_PC.PR) <- colnames(traits)
if (is.numeric(nperm)){
colnames(T_IP.IC_nm1) <- colnames(traits)
colnames(T_IC.IR_nm2) <- colnames(traits)
colnames(T_PC.PR_nm2sp) <- colnames(traits)
}
rownames(T_IP.IC) <- levels(as.factor(Tplosp))
rownames(T_IC.IR) <- levels(as.factor(Tplosp))
rownames(T_PC.PR) <- levels(as.factor(Tplosp))
#________________________________________
res <- list()
res$Tstats <- list()
res$Tstats$T_IP.IC <- T_IP.IC
res$Tstats$T_IC.IR <- T_IC.IR
res$Tstats$T_PC.PR <- T_PC.PR
res$variances <- list()
res$variances$var_IP <- var_IP
res$variances$var_PC <- var_PC
res$variances$var_CR <- var_CR
res$variances$var_IC <- var_IC
res$variances$var_PR <- var_PR
res$variances$var_IR <- var_IR
if (is.numeric(nperm)){
res$variances$var_IP_nm1 <- var_IP_nm1
res$variances$var_PC_nm2sp <- var_PC_nm2sp
res$variances$var_IC_nm1 <- var_IC_nm1
res$variances$var_IC_nm2 <- var_IC_nm2
res$variances$var_PR_nm2sp <- var_PR_nm2sp
res$variances$var_IR_nm2 <- var_IR_nm2
res$Tstats$T_IP.IC_nm <- T_IP.IC_nm1
res$Tstats$T_IC.IR_nm <- T_IC.IR_nm2
res$Tstats$T_PC.PR_nm <- T_PC.PR_nm2sp
}
else{}
res$traits <- traits
res$ind.plot <- ind.plot
res$sp <- sp
res$sites_richness <- table(ind.plot)
res$namestraits <- colnames(traits)
res$call <- match.call()
class(res) <- "Tstats"
invisible(res)
}
data(finch.ind)
res.finch <- Tstats(traits.finch, ind.plot = ind.plot.finch,
sp = sp.finch, nperm = 9, print = FALSE)
res.finch
library(cati)
data(finch.ind)
res.finch <- Tstats(traits.finch, ind.plot = ind.plot.finch,
sp = sp.finch, nperm = 9, print = FALSE)
res.finch
sdd<-0
unlist(sdd)
dim(unlist(sdd))
library(cati)
data(finch.ind)
res.finch <- Tstats(traits.finch, ind.plot = ind.plot.finch,
sp = sp.finch, nperm = 9, print = FALSE)
res.finch
traits = traits.finch; ind.plot = ind.plot.finch;                    sp = sp.finch; nperm = 9; print = FALSE
reg.pool = NULL; SE.reg.pool = NULL; nperm = 9; printprogress = TRUE
SE = 0
names_sp_ind.plot <- as.factor(paste(sp, ind.plot, sep = "@"))
Tplosp <- unlist(strsplit(levels(names_sp_ind.plot), split = "@"))[2*(1:nlevels(names_sp_ind.plot))]
names(Tplosp) <- levels(names_sp_ind.plot)
#Tplosp is the plot in wich the population is
if(!is.null(nperm)){
if (nperm == 0) {nperm = NULL}
}
########################################
####	calculation of observed values	####
########################################
#________________________________________
#Objects creation
mean_IP <- matrix(nrow = nlevels(names_sp_ind.plot), ncol = ncol(traits))
rownames(mean_IP) = levels(names_sp_ind.plot)
mean_PC <- matrix(nrow = nlevels(ind.plot), ncol = ncol(traits))
var_IP <- matrix(nrow = nlevels(names_sp_ind.plot), ncol = ncol(traits))
var_PC <- matrix(nrow = nlevels(ind.plot), ncol = ncol(traits))
var_CR <- vector()
var_IC <- matrix(nrow = nlevels(ind.plot), ncol = ncol(traits))
var_PR <- vector()
var_IR <- vector()
T_IP.IC <- matrix(nrow = nlevels(ind.plot), ncol = ncol(traits))
T_IC.IR <- matrix(nrow = nlevels(ind.plot), ncol = ncol(traits))
T_PC.PR <- matrix(nrow = nlevels(ind.plot), ncol = ncol(traits))
for (t in 1: ncol(traits)){
mean_IP[,t] <- tapply(traits[,t], names_sp_ind.plot  ,mean, na.rm = T)
mean_PC[,t] <- tapply(mean_IP[,t], Tplosp , mean, na.rm = T)
var_IP[,t] <- tapply(traits[,t], names_sp_ind.plot, var, na.rm = T)
var_PC[,t] <- tapply(mean_IP[,t], Tplosp  ,var, na.rm = T)
var_CR[t] <- var(mean_PC[,t], na.rm = T)
var_IC[,t] <- tapply(traits[,t], ind.plot  ,var, na.rm = T)
var_PR[t] <- var(as.vector(mean_IP[,t]), na.rm = T)
var_IR[t] <- var(traits[,t], na.rm = T)
for(s in 1 : nlevels(ind.plot)){
T_IP.IC[s,t] <- mean(var_IP[grepl(levels(ind.plot)[s],Tplosp),t], na.rm = T)/var_IC[s,t]
T_IC.IR[s,t] <- var_IC[s,t]/var_IR[t]
T_PC.PR[s,t] <- var_PC[s,t]/var_PR[t]
}
}
#________________________________________
#########################################
#### 	  Creating null models  	 ####
#########################################
#null model 1 = local
#null model 2 = regional.ind
#null model 2.sp = regional.pop
if (is.numeric(nperm)){
var_IP_nm1 <- array(dim = c(nperm,ncol(traits),nrow = length(Tplosp)))
var_PC_nm2sp <- array(dim = c(nperm,ncol(traits),nlevels(ind.plot)))
var_IC_nm1 <- array(dim = c(nperm,ncol(traits),nlevels(ind.plot)))
var_IC_nm2 <- array(dim = c(nperm,ncol(traits),nlevels(ind.plot)))
var_PR_nm2sp <- array(dim = c(nperm,ncol(traits)))
var_IR_nm2 <- array(dim = c(nperm,ncol(traits)))
mean_IP_nm2sp <- array(dim = c(nperm,ncol(traits),length(Tplosp)))
mean_PC_nm2sp <- array(dim = c(nperm,ncol(traits),nlevels(ind.plot)))
traits.nm1 <- list()
traits.nm2 <- list()
traits.nm2sp <- list()
T_IP.IC_nm1 <- array(dim = c(nperm,ncol(traits),nlevels(ind.plot)))
T_IC.IR_nm2 <- array(dim = c(nperm,ncol(traits),nlevels(ind.plot)))
T_PC.PR_nm2sp <- array(dim = c(nperm,ncol(traits),nlevels(ind.plot)))
#########################################
#### 	  Creating regional pools  	 ####
#########################################
if(is.null(SE.reg.pool)){
SE.reg.pool <- SE
}
#________________________________________
# Warnings and stop about standard errors parameter
if (length(SE) != ncol(traits) & length(SE) != 1) {
stop("The vector SE need to have a length of one or equal to the number of traits")
}
if(!is.null(reg.pool)){
if (length(unlist(SE.reg.pool)) != length(unlist(reg.pool))) {
stop("The vector SE.reg.pool need to have the same dimension as reg.pool")
}
}
#If the regional pool is the same for all communitiers:
#create a list of regional pool (one regional pool by community)
if (is.null(reg.pool)) {
reg.pool <- rep(list(traits), nlevels(ind.plot))
SE.reg.pool <- rep(list(SE.reg.pool), nlevels(ind.plot))
}
if (is.data.frame(reg.pool) | is.matrix(reg.pool) ) {
reg.pool <- rep(list(reg.pool), nlevels(ind.plot))
SE.reg.pool <- rep(list(SE.reg.pool), nlevels(ind.plot))
}
if(length(reg.pool) != nlevels(ind.plot)){
stop("reg.pool need to be either a matrix or a list of length equal to the number of communities")
}}
if(!is.null(reg.pool)){
if (length(unlist(SE.reg.pool)) != length(unlist(reg.pool))) {
stop("The vector SE.reg.pool need to have the same dimension as reg.pool")
}
}
length(unlist(SE.reg.pool))
length(unlist(reg.pool))
library(cati)
data(finch.ind)
res.finch <- Tstats(traits.finch, ind.plot = ind.plot.finch,
sp = sp.finch, nperm = 9, print = FALSE)
res.finch
Tstats
library(cati)
data(finch.ind)
res.finch <- Tstats(traits.finch, ind.plot = ind.plot.finch,
sp = sp.finch, nperm = 9, print = FALSE)
res.finch
library(cati)
library(cati)
data(finch.ind)
res.finch <- Tstats(traits.finch, ind.plot = ind.plot.finch,
sp = sp.finch, nperm = 9, print = FALSE)
res.finch
ncol(traits)
ncol(traits.finch)
data(finch.ind)
res.finch <- Tstats(traits.finch, ind.plot = ind.plot.finch,
sp = sp.finch, nperm = 9, print = FALSE)
res.finch
library(cati)
library(cati)
data(finch.ind)
res.finch <- Tstats(traits.finch, ind.plot = ind.plot.finch,
sp = sp.finch, nperm = 9, print = FALSE)
res.finch
traceback
traceback()
data(finch.ind)
res.finch <- Tstats(traits.finch, ind.plot = ind.plot.finch,
sp = sp.finch, nperm = 9, print = FALSE)
traceback()
