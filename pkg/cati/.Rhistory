res.finch.sp_by1<-ComIndex(traits=traits.finch.mice, index=funct.by1, sp=sp.finch,
nullmodels=rep(2,times=3), ind.plot=ind.plot.finch,
nperm=2, print=FALSE)
res.finch.sp_by1<-ComIndex(traits=traits.finch.mice, index=IndexByPop(funct1), sp=sp.finch,
nullmodels=rep(2,times=3), ind.plot=ind.plot.finch,
nperm=2, print=FALSE)
res.finch.sp_by1$obs
class(funct1)
funct1
funct.by1
IndexByPop(funct1)
ength(funct1)
length(funct1)
IndexByPop<-function(metrics, pop = "ind.plot.finch"){
IndexByPop<-c()
for (i in 1:length(metrics)){
IndexByPop<- c(funct.by1, paste("tapply(x, ", pop, ", function(x) ", funct1[i], ")", sep=""))
}
return(IndexByPop)
}
IndexByPop(funct1)
funct1
funct1[1]
funct1[2]
IndexByPop<-function(metrics, pop = "ind.plot.finch"){
IndexByPop<-c()
for (i in 1:length(metrics)){
IndexByPop<- c(IndexByPop, paste("tapply(x, ", pop, ", function(x) ", funct1[i], ")", sep=""))
}
return(IndexByPop)
}
IndexByPop(funct1)
res.finch.sp_by1<-ComIndex(traits=traits.finch.mice, index=IndexByPop(funct1), sp=sp.finch,
nullmodels=rep(2,times=3), ind.plot=ind.plot.finch,
nperm=2, print=FALSE)
res.finch.sp_by1
res.finch.sp_by1$obs
res.finch.sp_by2<-ComIndex(traits=traits.finch.mice, index=IndexByPop(funct2), sp=sp.finch,
nullmodels=rep(2,times=6), ind.plot=ind.plot.finch,
nperm=2, print=FALSE)
res.finch.sp_by2
res.finch.sp_by2$obs
IndexByPop(funct3)
length(funct3)
funct3
length(metrics)
IndexByPop<-function(metrics, pop = "ind.plot.finch"){
IndexByPop<-c()
for (i in 1:length(metrics)){
IndexByPop<- c(IndexByPop, paste("tapply(x, ", pop, ", function(x) ", funct1[i], ")", sep=""))
}
return(IndexByPop)
}
funct3[5]
IndexByPop(funct3)
metrics=funct3
length(metrics)
i=1
IndexByPop<- c(IndexByPop, paste("tapply(x, ", pop, ", function(x) ", funct1[i], ")", sep=""))
IndexByPop
IndexByPop<-function(metrics, pop = "ind.plot.finch"){
res<-c()
for (i in 1:length(metrics)){
res<- c(res, paste("tapply(x, ", pop, ", function(x) ", funct1[i], ")", sep=""))
}
return(res)
}
res<-c()
res<- c(res, paste("tapply(x, ", pop, ", function(x) ", funct1[i], ")", sep=""))
res
i=5
res<- c(res, paste("tapply(x, ", pop, ", function(x) ", funct1[i], ")", sep=""))
res
IndexByPop<-function(metrics, pop = "ind.plot.finch"){
res<-c()
for (i in 1:length(metrics)){
res<- c(res, paste("tapply(x, ", pop, ", function(x) ", metrics[i], ")", sep=""))
}
return(res)
}
res.finch.sp_by2<-ComIndex(traits=traits.finch.mice, index=IndexByPop(funct2), sp=sp.finch,
nullmodels=rep(2,times=6), ind.plot=ind.plot.finch,
nperm=2, print=FALSE)
res.finch.sp_by3<-ComIndex(traits=traits.finch.mice, index=IndexByPop(funct3), sp=sp.finch,
nullmodels=2, ind.plot=ind.plot.finch,
nperm=2, print=FALSE)
res.finch.sp_by3
res.finch.sp_by3$obs
IndexByPop(funct2)
funct.by2<-c("tapply(x, ind.plot.finch, function(x) weighted.mean(x, wt[[]))", "tapply(x, ind.plot.finch, function(x) wt.sd(x, wt))")
res.finch.sp_by2<-ComIndex(traits=traits.finch.mice, index=funct.by2, sp=sp.finch,
nullmodels=rep(2,times=6), ind.plot=ind.plot.finch,
nperm=2, print=FALSE)
funct.by2<-c("tapply(x, ind.plot.finch, function(x) weighted.mean(x, wt[[]))", "tapply(x, ind.plot.finch, function(x) wt.sd(x, wt))")
res.finch.sp_by2<-ComIndex(traits=traits.finch.mice, index=funct.by2, sp=sp.finch,
nullmodels=rep(2,times=6), ind.plot=ind.plot.finch,
nperm=2, print=FALSE)
funct.by2<-c("tapply(x, ind.plot.finch, function(x) weighted.mean(x, wt[[]]))", "tapply(x, ind.plot.finch, function(x) wt.sd(x, wt))")
res.finch.sp_by2<-ComIndex(traits=traits.finch.mice, index=funct.by2, sp=sp.finch,
nullmodels=rep(2,times=6), ind.plot=ind.plot.finch,
nperm=2, print=FALSE)
res.finch.sp_by3<-ComIndex(traits=traits.finch.mice, index=IndexByPop(funct3), sp=sp.finch,
funct.by2<-c("tapply(x, ind.plot.finch, function(x) weighted.mean(x, wt))", "tapply(x, ind.plot.finch, function(x) wt.sd(x, wt))")
res.finch.sp_by2<-ComIndex(traits=traits.finch.mice, index=funct.by2, sp=sp.finch,
nullmodels=rep(2,times=6), ind.plot=ind.plot.finch,
nperm=2, print=FALSE)
res.finch_2<-ComIndex(traits=traits.finch.mice, index=funct2, sp=sp.finch,
nullmodels=rep(2,times=2), ind.plot=ind.plot.finch,
nperm=2)
res.finch_2<-ComIndex(traits=traits.finch.mice, index=funct2, sp=sp.finch,
nullmodels=rep(2,times=2), ind.plot=ind.plot.finch,
nperm=2)
res.finch_2
res.finch_$obs
res.finch_2$$obs
res.finch_2$obs
res.finch_3<-ComIndex(traits=traits.finch.mice, index=funct3, sp=sp.finch,
nullmodels=rep(2,times=6), ind.plot=ind.plot.finch,
nperm=2)
funct5<-c("MinNND(x)", "MNND(x)", "SDNND(x)", "SDND(x)", "SDNND(x, div_range=T)", "SDND(x, div_range=T)")
res.finch_4<-ComIndex(traits=traits.finch.mice, index=funct4, sp=sp.finch,
nullmodels=2, ind.plot=ind.plot.finch,
nperm=2)
funct4<-c("SumBL(as.matrix(x))", "SumBL(as.matrix(x), gower.dist=F)")
res.finch_4<-ComIndex(traits=traits.finch.mice, index=funct4, sp=sp.finch,
nullmodels=2, ind.plot=ind.plot.finch,
nperm=2)
Q
funct4<-c("SumBL(as.matrix(x))", "SumBL(as.matrix(x), gower.dist=F)")
res.finch_4<-ComIndex(traits=traits.finch.mice, index=funct4, sp=sp.finch,
nullmodels=2, ind.plot=ind.plot.finch,
nperm=2)
res.finch_5<-ComIndex(traits=traits.finch.mice, index=funct5, sp=sp.finch,
nullmodels=2, ind.plot=ind.plot.finch,
nperm=2)
res.finch_5
res.finch_5$obs
#calculation of minimum NND for one trait or multiple traits with our without division by the range of the trait
MinNND <- function(traits, div_range=FALSE, na.rm=FALSE, scale.tr = TRUE, method.dist = "euclidian"){
#Multi-traits
if(is.matrix(traits) | is.data.frame(traits)){
if(scale.tr) {
traits<-apply(traits, 2, scale)
}
mat.dist<- dist(traits, method = method.dist)
mat.dist <- as.matrix(mat.dist)
mat.dist <- apply(mat.dist, 1, function(x) as.numeric(sub("^0$", NA, x)))
nnd<-apply(mat.dist, 1, function(x) min (x, na.rm=T))
}
#Uni-traits
else if(is.vector(traits)){
r=sort(traits)
if (length(r)<1){
nnd=NA
}
else{
nnd=vector(length=length(r)-1)
for(j in 2:length(r)){
nnd[j-1]=r[j]-r[j-1]
}
}
}
else{stop("traits must be vector or a matrix of traits")}
#Metric calculation
MinNND <- min(nnd[nnd>0], na.rm = na.rm)
if (div_range==T) {MinNND <- MinNND/range(traits, na.rm=na.rm)}
else {}
return(MinNND)
}
res.finch_5<-ComIndex(traits=traits.finch.mice, index=funct5, sp=sp.finch,
nullmodels=2, ind.plot=ind.plot.finch,
nperm=2)
plot(res.finch_5)
plot(res.finch_5)
plot(res.finch_5)
summary(res.finch_5)
#calculation of minimum NND for one trait or multiple traits with our without division by the range of the trait
MinNND <- function(traits, div_range=FALSE, na.rm=FALSE, scale.tr = TRUE, method.dist = "euclidian"){
#Multi-traits
if(is.matrix(traits) | is.data.frame(traits)){
if(scale.tr) {
traits<-apply(traits, 2, scale)
}
mat.dist<- dist(traits, method = method.dist)
mat.dist <- as.matrix(mat.dist)
mat.dist <- apply(mat.dist, 1, function(x) as.numeric(sub("^0$", NA, x)))
nnd<-apply(mat.dist, 1, function(x) min (x, na.rm=T))
}
#Uni-traits
else if(is.vector(traits)){
r=sort(traits)
if (length(r)<1){
nnd=NA
}
else{
nnd=vector(length=length(r)-1)
for(j in 2:length(r)){
nnd[j-1]=r[j]-r[j-1]
}
}
}
else{stop("traits must be vector or a matrix of traits")}
#Metric calculation
MinNND <- min(nnd[nnd>0], na.rm = na.rm)
if (div_range==T) {MinNND <- MinNND/range(traits, na.rm=na.rm)}
else {}
return(MinNND)
}
summary(res.finch_5)
#calculation of the coefficient of variation of the NND (nearest neigbour distance) for one trait with our without division by the range of the trait
CVNND <- function(traits, div_range=FALSE, na.rm=FALSE, scale.tr = TRUE, method.dist = "euclidian"){
#Multi-traits
if(is.vector(traits)){
traits<-as.matrix(traits, ncol=1)
}
else if(is.matrix(traits) | is.data.frame(traits)){
if(scale.tr) {
traits<-apply(traits, 2, scale)
}
mat.dist<- dist(traits, method = method.dist)
mat.dist <- as.matrix(mat.dist)
mat.dist <- apply(mat.dist, 1, function(x) as.numeric(sub("^0$", NA, x)))
nnd<-apply(mat.dist, 1, function(x) min (x, na.rm=T))
}
else{stop("traits must be vector or a matrix of traits")}
#Metric calculation
CVNND <- sd(nnd, na.rm = T)/mean(nnd, na.rm=T)
if (div_range==T) {CVNND <- CVNND/range(traits, na.rm=na.rm)}
else {}
return(CVNND)
}
CVNND(traits.finch)
CVNND(traits.finch[,1])
#calculation of the coefficient of variation of the NND (nearest neigbour distance) for one trait with our without division by the range of the trait
CVNND <- function(traits, div_range=FALSE, na.rm=FALSE, scale.tr = TRUE, method.dist = "euclidian"){
#Uni-traits vector transforme to a matrix
if(is.vector(traits)){
traits<-as.matrix(traits, ncol=1)
}
#Calcul of nearest neighbourhood distance
if(scale.tr) {
traits<-apply(traits, 2, scale)
}
mat.dist<- dist(traits, method = method.dist)
mat.dist <- as.matrix(mat.dist)
mat.dist <- apply(mat.dist, 1, function(x) as.numeric(sub("^0$", NA, x)))
nnd<-apply(mat.dist, 1, function(x) min (x, na.rm=T))
#Metric calculation
CVNND <- sd(nnd, na.rm = T)/mean(nnd, na.rm=T)
if (div_range==T) {CVNND <- CVNND/range(traits, na.rm=na.rm)}
else {}
return(CVNND)
}
CVNND(traits.finch[,1])
CVNND(traits.finch[1:100])
CVNND(traits.finch[1:100,])
CVNND(traits.finch[1:100,2])
traits<-traits.finch[1:10,1]
scale.tr=T
#Uni-traits vector transforme to a matrix
if(is.vector(traits)){
traits<-as.matrix(traits, ncol=1)
}
#Calcul of nearest neighbourhood distance
if(scale.tr) {
traits<-apply(traits, 2, scale)
}
mat.dist<- dist(traits, method = method.dist)
mat.dist <- as.matrix(mat.dist)
mat.dist <- apply(mat.dist, 1, function(x) as.numeric(sub("^0$", NA, x)))
nnd<-apply(mat.dist, 1, function(x) min (x, na.rm=T))
method.dist= "euclidian"
#Uni-traits vector transforme to a matrix
if(is.vector(traits)){
traits<-as.matrix(traits, ncol=1)
}
#Calcul of nearest neighbourhood distance
if(scale.tr) {
traits<-apply(traits, 2, scale)
}
mat.dist<- dist(traits, method = method.dist)
mat.dist <- as.matrix(mat.dist)
mat.dist <- apply(mat.dist, 1, function(x) as.numeric(sub("^0$", NA, x)))
nnd<-apply(mat.dist, 1, function(x) min (x, na.rm=T))
nnd
nnd
#Uni-traits vector transforme to a matrix
if(is.vector(traits)){
traits<-as.matrix(traits, ncol=1)
}
#Calcul of nearest neighbourhood distance
if(scale.tr) {
traits<-apply(traits, 2, scale)
}
mat.dist<- dist(traits, method = method.dist)
mat.dist <- as.matrix(mat.dist)
mat.dist <- apply(mat.dist, 1, function(x) as.numeric(sub("^0$", NA, x)))
nnd<-apply(mat.dist, 1, function(x) min (x, na.rm=T))
nnd
mat.dist
dim(mat.dist)
traits<-traits.finch[1:100,1]
#Uni-traits vector transforme to a matrix
if(is.vector(traits)){
traits<-as.matrix(traits, ncol=1)
}
#Calcul of nearest neighbourhood distance
if(scale.tr) {
traits<-apply(traits, 2, scale)
}
mat.dist<- dist(traits, method = method.dist)
mat.dist <- as.matrix(mat.dist)
mat.dist <- apply(mat.dist, 1, function(x) as.numeric(sub("^0$", NA, x)))
nnd<-apply(mat.dist, 1, function(x) min (x, na.rm=T))
nnd
0.1368691*2
traits<-traits.finch[1:100, 3]
#Uni-traits vector transforme to a matrix
if(is.vector(traits)){
traits<-as.matrix(traits, ncol=1)
}
#Calcul of nearest neighbourhood distance
if(scale.tr) {
traits<-apply(traits, 2, scale)
}
mat.dist<- dist(traits, method = method.dist)
mat.dist <- as.matrix(mat.dist)
mat.dist <- apply(mat.dist, 1, function(x) as.numeric(sub("^0$", NA, x)))
nnd<-apply(mat.dist, 1, function(x) min (x, na.rm=T))
nnd
traits<-traits.finch.mice[1:100, 3]
#Uni-traits vector transforme to a matrix
if(is.vector(traits)){
traits<-as.matrix(traits, ncol=1)
}
#Calcul of nearest neighbourhood distance
if(scale.tr) {
traits<-apply(traits, 2, scale)
}
mat.dist<- dist(traits, method = method.dist)
mat.dist <- as.matrix(mat.dist)
mat.dist <- apply(mat.dist, 1, function(x) as.numeric(sub("^0$", NA, x)))
nnd<-apply(mat.dist, 1, function(x) min (x, na.rm=T))
nnd
traits<-traits.finch.mice[1:10, 3]
traits<-sample(traits.finch.mice, 10)
?sample
sample(1:1000, 20)
traits<-traits.finch.mice[sample(1:1000, 20), 3]
traits
#Uni-traits vector transforme to a matrix
if(is.vector(traits)){
traits<-as.matrix(traits, ncol=1)
}
#Calcul of nearest neighbourhood distance
if(scale.tr) {
traits<-apply(traits, 2, scale)
}
mat.dist<- dist(traits, method = method.dist)
mat.dist <- as.matrix(mat.dist)
mat.dist <- apply(mat.dist, 1, function(x) as.numeric(sub("^0$", NA, x)))
nnd<-apply(mat.dist, 1, function(x) min (x, na.rm=T))
#Metric calculation
CVNND <- sd(nnd, na.rm = T)/mean(nnd, na.rm=T)
nnd
CVNND
traits<-traits.finch.mice[sample(1:1000, 20), 3]
#Uni-traits vector transforme to a matrix
if(is.vector(traits)){
traits<-as.matrix(traits, ncol=1)
}
#Calcul of nearest neighbourhood distance
if(scale.tr) {
traits<-apply(traits, 2, scale)
}
mat.dist<- dist(traits, method = method.dist)
mat.dist <- as.matrix(mat.dist)
mat.dist <- apply(mat.dist, 1, function(x) as.numeric(sub("^0$", NA, x)))
nnd<-apply(mat.dist, 1, function(x) min (x, na.rm=T))
#Metric calculation
CVNND <- sd(nnd, na.rm = T)/mean(nnd, na.rm=T)
nnd
CVNND(traits)
on of the coefficient of variation of the NND (nearest neigbour distance) for one trait with our without division by the range of the trait
CVNND <- function(traits, div_range=FALSE, na.rm=FALSE, scale.tr = TRUE, method.dist = "euclidian"){
#Uni-traits vector transforme to a matrix
if(is.vector(traits)){
traits<-as.matrix(traits, ncol=1)
}
#Calcul of nearest neighbourhood distance
if(scale.tr) {
traits<-apply(traits, 2, scale)
}
mat.dist<- dist(traits, method = method.dist)
mat.dist <- as.matrix(mat.dist)
mat.dist <- apply(mat.dist, 1, function(x) as.numeric(sub("^0$", NA, x)))
nnd<-apply(mat.dist, 1, function(x) min (x, na.rm=T))
#Metric calculation
CVNND <- sd(nnd, na.rm = T)/mean(nnd, na.rm=T)
if (div_range) {CVNND <- CVNND/range(traits, na.rm=na.rm)}
else {}
return(CVNND)
}
CVNND(traits)
CVNND(traits.finch)
CVNND(traits.finch[sample(1:1000,20),])
CVNND(traits.finch[sample(1:1000,20),1])
CVNND(traits.finch[sample(1:1000,20),1], div_range=T)
range(traits.finch)
range(traits.finch[,1])
range(traits.finch[,1], na.rm=T)
?range
library(cati)
5*240.24
basecit <- system.file("CITATION", package="base")
source(basecit, echo=TRUE)
readCitationFile(basecit)
source(basecit, echo=TRUE)
source(basecit)
citation()
w<-source(basecit)
<
w
w<-source(basecit, echo=T)
w
bibentry(w)
x<-bibentry(w)
x
citation("lattice")
x<-"citHeader("To cite the cati package:")
citEntry(
entry = "unpublished",
title = "cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits",
year = "2014",
author = "A. Taudiere and C. Violle",
)
"
citEntry(
+ entry = "unpublished",
+ title = "cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits",
+ year = "2014",
+ author = "A. Taudiere and C. Violle",
+ )
?citEntry
citHeader("To cite the cati package:")
citEntry(
textVersion = Taudiere & Violle. 2014. cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits."
entry = "unpublished",
title = "cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits",
year = "2014",
author = "A. Taudiere and C. Violle",
)
citEntry(
textVersion = "Taudiere & Violle. 2014. cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits."
entry = "unpublished",
title = "cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits",
year = "2014",
author = "A. Taudiere and C. Violle",
)
citEntry(
textVersion = "Taudiere and Violle. 2014. cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits."
entry = "unpublished",
title = "cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits",
year = "2014",
author = "A. Taudiere and C. Violle",
)
citEntry(
textVersion = "Taudiere and Violle. 2014. cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multilevel assembly processes using functional traits."
entry = "unpublished",
title = "cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits",
year = "2014",
author = "A. Taudiere and C. Violle",
)
citEntry(
textVersion = "Taudiere and Violle. 2014. cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multilevel assembly processes using functional traits."
entry = "unpublished",
title = "cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits",
year = "2014",
author = "A. Taudiere and C. Violle",
)
citEntry(
textVersion = "Taudiere and Violle. 2014. cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits.",
entry = "unpublished",
title = "cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits",
year = "2014",
author = "A. Taudiere and C. Violle",
)
citEntry(
textVersion = "Taudiere and Violle. 2014. cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits.",
entry = "unpublished",
title = "cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits",
year = "2014",
author = "A. Taudiere and C. Violle",
note=""
)
citEntry(
textVersion = "Taudiere and Violle. 2014. cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits.",
entry = "unpublished",
title = "cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits",
year = "2014",
author = "A. Taudiere and C. Violle",
note=" "
)
citEntry(
textVersion = "Taudiere and Violle. 2014. cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits.",
entry = "unpublished",
title = "cati (Community Assembly by Traits: Individuals and beyond  ): a R package to detect and quantify multi-level assembly processes using functional traits",
year = "2014",
author = "A. Taudiere and C. Violle",
note="under submission"
)
library(cati)
