<<<<<<< HEAD
#trait 1 : normal distribution
Data$trait1[i] = 1/2*(rnorm(1, mean.sp[which(Data$sp[i] == sp)], abs(mean.sp[which(Data$sp[i] == sp)])*cv_intra_sp) +
rnorm(1, mean.com[which(Data$com[i] == com)], abs(mean.com[which(Data$com[i] == com)])*cv_intra_com))# - mean(mean.com)
#trait 2 : uniform distribution
Data$trait2[i] = 1/2*(runif(1, mean.sp[which(Data$sp[i] == sp)]*(1-cv_intra_sp), abs(mean.sp[which(Data$sp[i] == sp)])*(1+cv_intra_sp)) +
runif(1, mean.com[which(Data$com[i] == com)]*(1-cv_intra_com), abs(mean.com[which(Data$com[i] == com)])*(1+cv_intra_com)))# - mean(mean.com)
}
}
Data$call <- match.call()
return(Data)
}
resN<-RandCom(Filter="None")
Ncom = 10; Nsp = 20; Nind.com = 100; sdlog = 1.5; min_value_traits = 80; max_value_traits = 200; cv_intra_sp = 1.5; cv_intra_com = 1.5; Int_Filter_Strength = 50; Ext_Filter_Strength = 50; Filter='None'
set <- letters
SET <- LETTERS
sp_Letters <- combn(set, round(Nsp/26/26)+1)
com_Letters <- combn(SET, round(Ncom/26/26)+1)
com <- paste("com", com_Letters[seq(1:Ncom)], sep ="_")
sp <- paste("sp",  sp_Letters[seq(1:Nsp)], sep ="_")
Nind <- Ncom * Nind.com
trait_distri = c("rnorm", "rlnorm") #For latter: may be an argument of the function
Ntr <- length(trait_distri)
Data = data.frame(matrix(0, ncol=2+Ntr, nrow=Nind)); colnames(Data) = c("com","sp","trait")
#____
# 1 - Assign a community to each individual
### HYP 1: all communities have the same number of individuals
Data$com = as.factor(rep(com, rep(Nind.com,length(com))))
#____
# 2 - Assign a species to each individual
### HYP 1: species abudances follow a lognormal distribution within each comm
### HYP 2: all species can be as abundant as each other within the regional pool (no rare/common species)
### HYP 3: species abundance is not linked to any type of gradient -> could we influence the distribution by both lognormal and gradient?
for(c in 1:Ncom){
ex.sp = sample(sp, size = Nind.com, prob = rlnorm(Nsp, 0, sdlog), replace = T)
Data$sp[((c-1)*Nind.com+1):(c*Nind.com)] = ex.sp
}
#trait1: normal distribution
Data$trait1 = rnorm(Nind, (max_value_traits-min_value_traits), (max_value_traits-min_value_traits) * cv_intra_sp)
#trait2: uniform distribution
Data$trait2 <- runif(Nind, min_value_traits, max_value_traits)
Data$trait2
set <- letters
SET <- LETTERS
sp_Letters <- combn(set, round(Nsp/26/26)+1)
com_Letters <- combn(SET, round(Ncom/26/26)+1)
com <- paste("com", com_Letters[seq(1:Ncom)], sep ="_")
sp <- paste("sp",  sp_Letters[seq(1:Nsp)], sep ="_")
Nind <- Ncom * Nind.com
trait_distri = c("rnorm", "rlnorm") #For latter: may be an argument of the function
Ntr <- length(trait_distri)
Data = data.frame(matrix(0, ncol=2+Ntr, nrow=Nind)); colnames(Data) = c("com","sp","trait")
RandCom <- function(Ncom = 10, Nsp = 20, Nind.com = 100, sdlog = 1.5, min_value_traits = 80, max_value_traits = 200, cv_intra_sp = 1.5, cv_intra_com = 1.5, Int_Filter_Strength = 50, Ext_Filter_Strength = 50, Filter='None'){
## Filter=c('None', 'External', 'Internal', 'Both')
set <- letters
SET <- LETTERS
sp_Letters <- combn(set, round(Nsp/26/26)+1)
com_Letters <- combn(SET, round(Ncom/26/26)+1)
com <- paste("com", com_Letters[seq(1:Ncom)], sep ="_")
sp <- paste("sp",  sp_Letters[seq(1:Nsp)], sep ="_")
Nind <- Ncom * Nind.com
trait_distri = c("rnorm", "rlnorm") #For latter: may be an argument of the function
Ntr <- length(trait_distri)
Data = data.frame(matrix(0, ncol=2+Ntr, nrow=Nind)); colnames(Data) = c("com","sp","trait")
#____
# 1 - Assign a community to each individual
### HYP 1: all communities have the same number of individuals
Data$com = as.factor(rep(com, rep(Nind.com,length(com))))
#____
# 2 - Assign a species to each individual
### HYP 1: species abudances follow a lognormal distribution within each comm
### HYP 2: all species can be as abundant as each other within the regional pool (no rare/common species)
### HYP 3: species abundance is not linked to any type of gradient -> could we influence the distribution by both lognormal and gradient?
for(c in 1:Ncom){
ex.sp = sample(sp, size = Nind.com, prob = rlnorm(Nsp, 0, sdlog), replace = T)
Data$sp[((c-1)*Nind.com+1):(c*Nind.com)] = ex.sp
}
#____
# 3 - Assign a trait value to each individual
## OPTION 1: random ##
if(Filter=='None'){
#trait1: normal distribution
Data$trait1 = rnorm(Nind, (max_value_traits-min_value_traits), (max_value_traits-min_value_traits) * cv_intra_sp)
#trait2: uniform distribution
Data$trait2 <- runif(Nind, min_value_traits, max_value_traits)
}
## OPTION 2: internal filtering ##
if(Filter=='Internal'){
# Parameter for the distance between species mean trait values:
### HYP 1: the most extreme case (if Int_Filter_Strength==100) species have equally distributed mean values along the trait gradient
Init_sp_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Nsp)), 2)
# Defining traits mean by species
mean.sp <- sample(rnorm(Nsp, mean = Init_sp_mean, sd = 100-Int_Filter_Strength), replace=F)
#mean.sp[mean.sp<0] = runif(sum(mean.sp<0), min_value_traits, max_value_traits) ## to avoid negative values!!!
#--- I think it's not necessary if we use the absolute value for the variance
# Draw the individual traits values depending on species attributes
for(i in 1:Nind){
#trait 1 : normal distribution
Data$trait1[i] = rnorm(1, mean.sp[which(Data$sp[i] == sp)], abs(mean.sp[which(Data$sp[i] == sp)])*cv_intra_sp)
#trait 2 : uniform distribution
Data$trait2[i] = runif(1, mean.sp[which(Data$sp[i] == sp)]*(1-cv_intra_sp), abs(mean.sp[which(Data$sp[i] == sp)])*(1+cv_intra_sp))
}
}
## OPTION 3: external filtering ##
if(Filter=='External'){
# Parameter for the distance between communities mean trait values:
### HYP 1: the most extreme case (if Ext_Filter_Strength==100) communities have equally distributed mean values along the trait gradient
Init_com_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Ncom)), 2)
# Defining traits mean by community
mean.com <- sample(rnorm(Ncom, mean = Init_com_mean, sd = 100-Ext_Filter_Strength), replace=F)
#mean.com[mean.com<0] = runif(sum(mean.com<0),min_value_traits, max_value_traits) ## to avoid negative values!!!
# Draw the individual traits depending on communities attributes
for(i in 1:Nind){
#trait 1 : normal distribution
Data$trait1[i] = rnorm(1, mean.com[which(Data$com[i] == com)], abs(mean.com[which(Data$com[i] == com)])*cv_intra_com)
#trait 2 : uniform distribution
Data$trait2[i] = runif(1, mean.com[which(Data$com[i] == com)]*(1-cv_intra_com), abs(mean.com[which(Data$com[i] == com)])*(1+cv_intra_com))
}
}
## OPTION 4: external and internal filtering ##
if(Filter=='Both'){
# Parameter for the distance between species mean trait values:
### HYP 1: the most extreme case (if Int_Filter_Strength==100) species have equally distributed mean values along the trait gradient
Init_sp_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Nsp)), 2)
# Defining traits mean by species
mean.sp <- sample(rnorm(Nsp, mean = Init_sp_mean, sd = 100-Int_Filter_Strength), replace = FALSE)
# Parameter for the distance between communities mean trait values:
### HYP 1: the most extreme case (if Ext_Filter_Strength==100) communities have equally distributed mean values along the trait gradient
Init_com_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Ncom)), 2)
# Defining traits mean by community
mean.com <- sample(rnorm(Ncom, mean = Init_com_mean, sd = 100-Ext_Filter_Strength), replace = FALSE)
# Draw the individual traits values depending on species attributes
for(i in 1:Nind){
#trait 1 : normal distribution
Data$trait1[i] = 1/2*(rnorm(1, mean.sp[which(Data$sp[i] == sp)], abs(mean.sp[which(Data$sp[i] == sp)])*cv_intra_sp) +
rnorm(1, mean.com[which(Data$com[i] == com)], abs(mean.com[which(Data$com[i] == com)])*cv_intra_com))# - mean(mean.com)
#trait 2 : uniform distribution
Data$trait2[i] = 1/2*(runif(1, mean.sp[which(Data$sp[i] == sp)]*(1-cv_intra_sp), abs(mean.sp[which(Data$sp[i] == sp)])*(1+cv_intra_sp)) +
runif(1, mean.com[which(Data$com[i] == com)]*(1-cv_intra_com), abs(mean.com[which(Data$com[i] == com)])*(1+cv_intra_com)))# - mean(mean.com)
}
}
Data$call <- match.call()
return(Data)
}
resN<-RandCom
resN<-RandCom()
resN<-RandCom
resN
resN<-RandCom()
resN<-RandCom(10)
resN<-RandCom(10,10)
resN<-RandCom(100,10)
RandCom <- function(Ncom = 10, Nsp = 20, Nind.com = 100, sdlog = 1.5, min_value_traits = 80, max_value_traits = 200, cv_intra_sp = 1.5, cv_intra_com = 1.5, Int_Filter_Strength = 50, Ext_Filter_Strength = 50, Filter='None'){
## Filter=c('None', 'External', 'Internal', 'Both')
set <- letters
SET <- LETTERS
sp_Letters <- combn(set, round(Nsp/26/26)+1)
com_Letters <- combn(SET, round(Ncom/26/26)+1) }
resN<-RandCom(100,10)
resN
RandCom <- function(Ncom = 10, Nsp = 20, Nind.com = 100, sdlog = 1.5, min_value_traits = 80, max_value_traits = 200, cv_intra_sp = 1.5, cv_intra_com = 1.5, Int_Filter_Strength = 50, Ext_Filter_Strength = 50, Filter='None'){
## Filter=c('None', 'External', 'Internal', 'Both')
set <- letters
SET <- LETTERS
sp_Letters <- combn(set, round(Nsp/26/26)+1)
com_Letters <- combn(SET, round(Ncom/26/26)+1)
com <- paste("com", com_Letters[seq(1:Ncom)], sep ="_")
sp <- paste("sp",  sp_Letters[seq(1:Nsp)], sep ="_")
Nind <- Ncom * Nind.com
trait_distri = c("rnorm", "rlnorm") #For latter: may be an argument of the function
Ntr <- length(trait_distri)
Data = data.frame(matrix(0, ncol=2+Ntr, nrow=Nind)); colnames(Data) = c("com","sp","trait")
}
resN
resN<-RandCom(100,10)
resN
RandCom <- function(Ncom = 10, Nsp = 20, Nind.com = 100, sdlog = 1.5, min_value_traits = 80, max_value_traits = 200, cv_intra_sp = 1.5, cv_intra_com = 1.5, Int_Filter_Strength = 50, Ext_Filter_Strength = 50, Filter='None'){
## Filter=c('None', 'External', 'Internal', 'Both')
set <- letters
SET <- LETTERS
sp_Letters <- combn(set, round(Nsp/26/26)+1)
com_Letters <- combn(SET, round(Ncom/26/26)+1)
com <- paste("com", com_Letters[seq(1:Ncom)], sep ="_")
sp <- paste("sp",  sp_Letters[seq(1:Nsp)], sep ="_")
Nind <- Ncom * Nind.com
trait_distri = c("rnorm", "rlnorm") #For latter: may be an argument of the function
Ntr <- length(trait_distri)
Data = data.frame(matrix(0, ncol=2+Ntr, nrow=Nind)); colnames(Data) = c("com","sp","trait")
#____
# 1 - Assign a community to each individual
### HYP 1: all communities have the same number of individuals
Data$com = as.factor(rep(com, rep(Nind.com,length(com))))
#____
# 2 - Assign a species to each individual
### HYP 1: species abudances follow a lognormal distribution within each comm
### HYP 2: all species can be as abundant as each other within the regional pool (no rare/common species)
### HYP 3: species abundance is not linked to any type of gradient -> could we influence the distribution by both lognormal and gradient?
for(c in 1:Ncom){
ex.sp = sample(sp, size = Nind.com, prob = rlnorm(Nsp, 0, sdlog), replace = T)
Data$sp[((c-1)*Nind.com+1):(c*Nind.com)] = ex.sp
}
#____
# 3 - Assign a trait value to each individual
## OPTION 1: random ##
if(Filter=='None'){
#trait1: normal distribution
Data$trait1 = rnorm(Nind, (max_value_traits-min_value_traits), (max_value_traits-min_value_traits) * cv_intra_sp)
#trait2: uniform distribution
Data$trait2 <- runif(Nind, min_value_traits, max_value_traits)
}}
resN<-RandCom(100,10)
resN
Data$call <- match.call()
RandCom <- function(Ncom = 10, Nsp = 20, Nind.com = 100, sdlog = 1.5, min_value_traits = 80, max_value_traits = 200, cv_intra_sp = 1.5, cv_intra_com = 1.5, Int_Filter_Strength = 50, Ext_Filter_Strength = 50, Filter='None'){
## Filter=c('None', 'External', 'Internal', 'Both')
set <- letters
SET <- LETTERS
sp_Letters <- combn(set, round(Nsp/26/26)+1)
com_Letters <- combn(SET, round(Ncom/26/26)+1)
com <- paste("com", com_Letters[seq(1:Ncom)], sep ="_")
sp <- paste("sp",  sp_Letters[seq(1:Nsp)], sep ="_")
Nind <- Ncom * Nind.com
trait_distri = c("rnorm", "rlnorm") #For latter: may be an argument of the function
Ntr <- length(trait_distri)
Data = data.frame(matrix(0, ncol=2+Ntr, nrow=Nind)); colnames(Data) = c("com","sp","trait")
#____
# 1 - Assign a community to each individual
### HYP 1: all communities have the same number of individuals
Data$com = as.factor(rep(com, rep(Nind.com,length(com))))
#____
# 2 - Assign a species to each individual
### HYP 1: species abudances follow a lognormal distribution within each comm
### HYP 2: all species can be as abundant as each other within the regional pool (no rare/common species)
### HYP 3: species abundance is not linked to any type of gradient -> could we influence the distribution by both lognormal and gradient?
for(c in 1:Ncom){
ex.sp = sample(sp, size = Nind.com, prob = rlnorm(Nsp, 0, sdlog), replace = T)
Data$sp[((c-1)*Nind.com+1):(c*Nind.com)] = ex.sp
}
#____
# 3 - Assign a trait value to each individual
## OPTION 1: random ##
if(Filter=='None'){
#trait1: normal distribution
Data$trait1 = rnorm(Nind, (max_value_traits-min_value_traits), (max_value_traits-min_value_traits) * cv_intra_sp)
#trait2: uniform distribution
Data$trait2 <- runif(Nind, min_value_traits, max_value_traits)
}
## OPTION 2: internal filtering ##
if(Filter=='Internal'){
# Parameter for the distance between species mean trait values:
### HYP 1: the most extreme case (if Int_Filter_Strength==100) species have equally distributed mean values along the trait gradient
Init_sp_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Nsp)), 2)
# Defining traits mean by species
mean.sp <- sample(rnorm(Nsp, mean = Init_sp_mean, sd = 100-Int_Filter_Strength), replace=F)
#mean.sp[mean.sp<0] = runif(sum(mean.sp<0), min_value_traits, max_value_traits) ## to avoid negative values!!!
#--- I think it's not necessary if we use the absolute value for the variance
# Draw the individual traits values depending on species attributes
for(i in 1:Nind){
#trait 1 : normal distribution
Data$trait1[i] = rnorm(1, mean.sp[which(Data$sp[i] == sp)], abs(mean.sp[which(Data$sp[i] == sp)])*cv_intra_sp)
#trait 2 : uniform distribution
Data$trait2[i] = runif(1, mean.sp[which(Data$sp[i] == sp)]*(1-cv_intra_sp), abs(mean.sp[which(Data$sp[i] == sp)])*(1+cv_intra_sp))
}
}
## OPTION 3: external filtering ##
if(Filter=='External'){
# Parameter for the distance between communities mean trait values:
### HYP 1: the most extreme case (if Ext_Filter_Strength==100) communities have equally distributed mean values along the trait gradient
Init_com_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Ncom)), 2)
# Defining traits mean by community
mean.com <- sample(rnorm(Ncom, mean = Init_com_mean, sd = 100-Ext_Filter_Strength), replace=F)
#mean.com[mean.com<0] = runif(sum(mean.com<0),min_value_traits, max_value_traits) ## to avoid negative values!!!
# Draw the individual traits depending on communities attributes
for(i in 1:Nind){
#trait 1 : normal distribution
Data$trait1[i] = rnorm(1, mean.com[which(Data$com[i] == com)], abs(mean.com[which(Data$com[i] == com)])*cv_intra_com)
#trait 2 : uniform distribution
Data$trait2[i] = runif(1, mean.com[which(Data$com[i] == com)]*(1-cv_intra_com), abs(mean.com[which(Data$com[i] == com)])*(1+cv_intra_com))
}
}
## OPTION 4: external and internal filtering ##
if(Filter=='Both'){
# Parameter for the distance between species mean trait values:
### HYP 1: the most extreme case (if Int_Filter_Strength==100) species have equally distributed mean values along the trait gradient
Init_sp_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Nsp)), 2)
# Defining traits mean by species
mean.sp <- sample(rnorm(Nsp, mean = Init_sp_mean, sd = 100-Int_Filter_Strength), replace = FALSE)
# Parameter for the distance between communities mean trait values:
### HYP 1: the most extreme case (if Ext_Filter_Strength==100) communities have equally distributed mean values along the trait gradient
Init_com_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Ncom)), 2)
# Defining traits mean by community
mean.com <- sample(rnorm(Ncom, mean = Init_com_mean, sd = 100-Ext_Filter_Strength), replace = FALSE)
# Draw the individual traits values depending on species attributes
for(i in 1:Nind){
#trait 1 : normal distribution
Data$trait1[i] = 1/2*(rnorm(1, mean.sp[which(Data$sp[i] == sp)], abs(mean.sp[which(Data$sp[i] == sp)])*cv_intra_sp) +
rnorm(1, mean.com[which(Data$com[i] == com)], abs(mean.com[which(Data$com[i] == com)])*cv_intra_com))# - mean(mean.com)
#trait 2 : uniform distribution
Data$trait2[i] = 1/2*(runif(1, mean.sp[which(Data$sp[i] == sp)]*(1-cv_intra_sp), abs(mean.sp[which(Data$sp[i] == sp)])*(1+cv_intra_sp)) +
runif(1, mean.com[which(Data$com[i] == com)]*(1-cv_intra_com), abs(mean.com[which(Data$com[i] == com)])*(1+cv_intra_com)))# - mean(mean.com)
}
}
res$data <- Data
res$call <- match.call()
return(Data)
}
resN<-RandCom(100,10)
resN<-RandCom()
RandCom <- function(Ncom = 10, Nsp = 20, Nind.com = 100, sdlog = 1.5, min_value_traits = 80, max_value_traits = 200, cv_intra_sp = 1.5, cv_intra_com = 1.5, Int_Filter_Strength = 50, Ext_Filter_Strength = 50, Filter='None'){
## Filter=c('None', 'External', 'Internal', 'Both')
set <- letters
SET <- LETTERS
sp_Letters <- combn(set, round(Nsp/26/26)+1)
com_Letters <- combn(SET, round(Ncom/26/26)+1)
com <- paste("com", com_Letters[seq(1:Ncom)], sep ="_")
sp <- paste("sp",  sp_Letters[seq(1:Nsp)], sep ="_")
Nind <- Ncom * Nind.com
trait_distri = c("rnorm", "rlnorm") #For latter: may be an argument of the function
Ntr <- length(trait_distri)
Data <- data.frame(matrix(0, ncol=2+Ntr, nrow=Nind)); colnames(Data) = c("com","sp","trait")
#____
# 1 - Assign a community to each individual
### HYP 1: all communities have the same number of individuals
Data$com = as.factor(rep(com, rep(Nind.com,length(com))))
#____
# 2 - Assign a species to each individual
### HYP 1: species abudances follow a lognormal distribution within each comm
### HYP 2: all species can be as abundant as each other within the regional pool (no rare/common species)
### HYP 3: species abundance is not linked to any type of gradient -> could we influence the distribution by both lognormal and gradient?
for(c in 1:Ncom){
ex.sp = sample(sp, size = Nind.com, prob = rlnorm(Nsp, 0, sdlog), replace = T)
Data$sp[((c-1)*Nind.com+1):(c*Nind.com)] = ex.sp
}
#____
# 3 - Assign a trait value to each individual
## OPTION 1: random ##
if(Filter=='None'){
#trait1: normal distribution
Data$trait1 = rnorm(Nind, (max_value_traits-min_value_traits), (max_value_traits-min_value_traits) * cv_intra_sp)
#trait2: uniform distribution
Data$trait2 <- runif(Nind, min_value_traits, max_value_traits)
}
## OPTION 2: internal filtering ##
if(Filter=='Internal'){
# Parameter for the distance between species mean trait values:
### HYP 1: the most extreme case (if Int_Filter_Strength==100) species have equally distributed mean values along the trait gradient
Init_sp_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Nsp)), 2)
# Defining traits mean by species
mean.sp <- sample(rnorm(Nsp, mean = Init_sp_mean, sd = 100-Int_Filter_Strength), replace=F)
#mean.sp[mean.sp<0] = runif(sum(mean.sp<0), min_value_traits, max_value_traits) ## to avoid negative values!!!
#--- I think it's not necessary if we use the absolute value for the variance
# Draw the individual traits values depending on species attributes
for(i in 1:Nind){
#trait 1 : normal distribution
Data$trait1[i] = rnorm(1, mean.sp[which(Data$sp[i] == sp)], abs(mean.sp[which(Data$sp[i] == sp)])*cv_intra_sp)
#trait 2 : uniform distribution
Data$trait2[i] = runif(1, mean.sp[which(Data$sp[i] == sp)]*(1-cv_intra_sp), abs(mean.sp[which(Data$sp[i] == sp)])*(1+cv_intra_sp))
}
}
## OPTION 3: external filtering ##
if(Filter=='External'){
# Parameter for the distance between communities mean trait values:
### HYP 1: the most extreme case (if Ext_Filter_Strength==100) communities have equally distributed mean values along the trait gradient
Init_com_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Ncom)), 2)
# Defining traits mean by community
mean.com <- sample(rnorm(Ncom, mean = Init_com_mean, sd = 100-Ext_Filter_Strength), replace=F)
#mean.com[mean.com<0] = runif(sum(mean.com<0),min_value_traits, max_value_traits) ## to avoid negative values!!!
# Draw the individual traits depending on communities attributes
for(i in 1:Nind){
#trait 1 : normal distribution
Data$trait1[i] = rnorm(1, mean.com[which(Data$com[i] == com)], abs(mean.com[which(Data$com[i] == com)])*cv_intra_com)
#trait 2 : uniform distribution
Data$trait2[i] = runif(1, mean.com[which(Data$com[i] == com)]*(1-cv_intra_com), abs(mean.com[which(Data$com[i] == com)])*(1+cv_intra_com))
}
}
## OPTION 4: external and internal filtering ##
if(Filter=='Both'){
# Parameter for the distance between species mean trait values:
### HYP 1: the most extreme case (if Int_Filter_Strength==100) species have equally distributed mean values along the trait gradient
Init_sp_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Nsp)), 2)
# Defining traits mean by species
mean.sp <- sample(rnorm(Nsp, mean = Init_sp_mean, sd = 100-Int_Filter_Strength), replace = FALSE)
# Parameter for the distance between communities mean trait values:
### HYP 1: the most extreme case (if Ext_Filter_Strength==100) communities have equally distributed mean values along the trait gradient
Init_com_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Ncom)), 2)
# Defining traits mean by community
mean.com <- sample(rnorm(Ncom, mean = Init_com_mean, sd = 100-Ext_Filter_Strength), replace = FALSE)
# Draw the individual traits values depending on species attributes
for(i in 1:Nind){
#trait 1 : normal distribution
Data$trait1[i] = 1/2*(rnorm(1, mean.sp[which(Data$sp[i] == sp)], abs(mean.sp[which(Data$sp[i] == sp)])*cv_intra_sp) +
rnorm(1, mean.com[which(Data$com[i] == com)], abs(mean.com[which(Data$com[i] == com)])*cv_intra_com))# - mean(mean.com)
#trait 2 : uniform distribution
Data$trait2[i] = 1/2*(runif(1, mean.sp[which(Data$sp[i] == sp)]*(1-cv_intra_sp), abs(mean.sp[which(Data$sp[i] == sp)])*(1+cv_intra_sp)) +
runif(1, mean.com[which(Data$com[i] == com)]*(1-cv_intra_com), abs(mean.com[which(Data$com[i] == com)])*(1+cv_intra_com)))# - mean(mean.com)
}
}
res <- list()
res$data <- Data
res$call <- match.call()
return(Data)
}
resN<-RandCom()
resN
resN$call
resN<-RandCom()
attributes(resN)
Ntr
Data <- data.frame(matrix(0, ncol=2+Ntr, nrow=Nind)); colnames(Data) = c("com","sp","trait")
Data
Data <- data.frame(matrix(0, ncol=2+Ntr, nrow=Nind)); colnames(Data) = c("com","sp","trait")
Data
Data <- data.frame(matrix(0, ncol=2+Ntr, nrow=Nind)); colnames(Data) = c("com","sp","trait1","trait2")
Data
RandCom <- function(Ncom = 10, Nsp = 20, Nind.com = 100, sdlog = 1.5, min_value_traits = 80, max_value_traits = 200, cv_intra_sp = 1.5, cv_intra_com = 1.5, Int_Filter_Strength = 50, Ext_Filter_Strength = 50, Filter='None'){
## Filter=c('None', 'External', 'Internal', 'Both')
set <- letters
SET <- LETTERS
sp_Letters <- combn(set, round(Nsp/26/26)+1)
com_Letters <- combn(SET, round(Ncom/26/26)+1)
com <- paste("com", com_Letters[seq(1:Ncom)], sep ="_")
sp <- paste("sp",  sp_Letters[seq(1:Nsp)], sep ="_")
Nind <- Ncom * Nind.com
trait_distri = c("rnorm", "rlnorm") #For latter: may be an argument of the function
Ntr <- length(trait_distri)
Data <- data.frame(matrix(0, ncol=2+Ntr, nrow=Nind)); colnames(Data) = c("com","sp","trait1","trait2")
#____
# 1 - Assign a community to each individual
### HYP 1: all communities have the same number of individuals
Data$com = as.factor(rep(com, rep(Nind.com,length(com))))
#____
# 2 - Assign a species to each individual
### HYP 1: species abudances follow a lognormal distribution within each comm
### HYP 2: all species can be as abundant as each other within the regional pool (no rare/common species)
### HYP 3: species abundance is not linked to any type of gradient -> could we influence the distribution by both lognormal and gradient?
for(c in 1:Ncom){
ex.sp = sample(sp, size = Nind.com, prob = rlnorm(Nsp, 0, sdlog), replace = T)
Data$sp[((c-1)*Nind.com+1):(c*Nind.com)] = ex.sp
}
#____
# 3 - Assign a trait value to each individual
## OPTION 1: random ##
if(Filter=='None'){
#trait1: normal distribution
Data$trait1 = rnorm(Nind, (max_value_traits-min_value_traits), (max_value_traits-min_value_traits) * cv_intra_sp)
#trait2: uniform distribution
Data$trait2 <- runif(Nind, min_value_traits, max_value_traits)
}
## OPTION 2: internal filtering ##
if(Filter=='Internal'){
# Parameter for the distance between species mean trait values:
### HYP 1: the most extreme case (if Int_Filter_Strength==100) species have equally distributed mean values along the trait gradient
Init_sp_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Nsp)), 2)
# Defining traits mean by species
mean.sp <- sample(rnorm(Nsp, mean = Init_sp_mean, sd = 100-Int_Filter_Strength), replace=F)
#mean.sp[mean.sp<0] = runif(sum(mean.sp<0), min_value_traits, max_value_traits) ## to avoid negative values!!!
#--- I think it's not necessary if we use the absolute value for the variance
# Draw the individual traits values depending on species attributes
for(i in 1:Nind){
#trait 1 : normal distribution
Data$trait1[i] = rnorm(1, mean.sp[which(Data$sp[i] == sp)], abs(mean.sp[which(Data$sp[i] == sp)])*cv_intra_sp)
#trait 2 : uniform distribution
Data$trait2[i] = runif(1, mean.sp[which(Data$sp[i] == sp)]*(1-cv_intra_sp), abs(mean.sp[which(Data$sp[i] == sp)])*(1+cv_intra_sp))
}
}
## OPTION 3: external filtering ##
if(Filter=='External'){
# Parameter for the distance between communities mean trait values:
### HYP 1: the most extreme case (if Ext_Filter_Strength==100) communities have equally distributed mean values along the trait gradient
Init_com_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Ncom)), 2)
# Defining traits mean by community
mean.com <- sample(rnorm(Ncom, mean = Init_com_mean, sd = 100-Ext_Filter_Strength), replace=F)
#mean.com[mean.com<0] = runif(sum(mean.com<0),min_value_traits, max_value_traits) ## to avoid negative values!!!
# Draw the individual traits depending on communities attributes
for(i in 1:Nind){
#trait 1 : normal distribution
Data$trait1[i] = rnorm(1, mean.com[which(Data$com[i] == com)], abs(mean.com[which(Data$com[i] == com)])*cv_intra_com)
#trait 2 : uniform distribution
Data$trait2[i] = runif(1, mean.com[which(Data$com[i] == com)]*(1-cv_intra_com), abs(mean.com[which(Data$com[i] == com)])*(1+cv_intra_com))
}
}
## OPTION 4: external and internal filtering ##
if(Filter=='Both'){
# Parameter for the distance between species mean trait values:
### HYP 1: the most extreme case (if Int_Filter_Strength==100) species have equally distributed mean values along the trait gradient
Init_sp_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Nsp)), 2)
# Defining traits mean by species
mean.sp <- sample(rnorm(Nsp, mean = Init_sp_mean, sd = 100-Int_Filter_Strength), replace = FALSE)
# Parameter for the distance between communities mean trait values:
### HYP 1: the most extreme case (if Ext_Filter_Strength==100) communities have equally distributed mean values along the trait gradient
Init_com_mean <- round(sort(seq(min_value_traits, max_value_traits, length.out = Ncom)), 2)
# Defining traits mean by community
mean.com <- sample(rnorm(Ncom, mean = Init_com_mean, sd = 100-Ext_Filter_Strength), replace = FALSE)
# Draw the individual traits values depending on species attributes
for(i in 1:Nind){
#trait 1 : normal distribution
Data$trait1[i] = 1/2*(rnorm(1, mean.sp[which(Data$sp[i] == sp)], abs(mean.sp[which(Data$sp[i] == sp)])*cv_intra_sp) +
rnorm(1, mean.com[which(Data$com[i] == com)], abs(mean.com[which(Data$com[i] == com)])*cv_intra_com))# - mean(mean.com)
#trait 2 : uniform distribution
Data$trait2[i] = 1/2*(runif(1, mean.sp[which(Data$sp[i] == sp)]*(1-cv_intra_sp), abs(mean.sp[which(Data$sp[i] == sp)])*(1+cv_intra_sp)) +
runif(1, mean.com[which(Data$com[i] == com)]*(1-cv_intra_com), abs(mean.com[which(Data$com[i] == com)])*(1+cv_intra_com)))# - mean(mean.com)
}
}
res <- list()
res$data <- Data
res$call <- match.call()
return(res)
}
resN<-RandCom()
resN$call
attributes(resN)
attributes(resN$data)
=======
for(t in 1:ntr){
if (length(na.omit(traits[as.factor(var.1) == levels(as.factor(var.1))[co],t]))>1){
#Define the limit for the plot
xli.interm <- c()
yli.interm <- c()
xlimin.interm <- c()
ylimin.interm <- c()
for(s in 1:nlevels(as.factor(var.2))) {
if (length(na.omit(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t]))>1) {
xli.interm[s] <- max(density(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t], na.rm = T)$x, na.rm = TRUE)
yli.interm[s] <- max(density(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t], na.rm = T)$y, na.rm = TRUE)
xlimin.interm[s] <- min(density(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t], na.rm = T)$x, na.rm = TRUE)
ylimin.interm[s] <- min(density(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t], na.rm = T)$y, na.rm = TRUE)
}
}
if(is.null(xlim)){
xli <- max(xli.interm, na.rm = TRUE)
xlimin <- min(xlimin.interm, na.rm = TRUE)
xlim = c(min(c(min(density(traits[,t], na.rm = T)$x), xlimin)), max(c(max(density(traits[,t], na.rm = T)$x, na.rm = T), xli)))
}
if(is.null(ylim)){
yli <- max(yli.interm, na.rm = TRUE)
ylimin <- min(ylimin.interm, na.rm = TRUE)
ylim = c(min(c(min(density(traits[,t], na.rm = T)$y), ylimin)), max(c(max(density(traits[,t], na.rm = T)$y, na.rm = T), yli))*1.05)
}
#Plot the regional distribution
plot(main = paste(namestraits[t],levels(as.factor(var.1))[co], " "), density(traits[as.factor(var.1) == levels(as.factor(var.1))[co],t], na.rm = T), ylim = ylim, xlim = xlim, col = "black")
lines(density(traits[,t], na.rm = T), lty = 2, col = "grey")
if (polyg == T) {
x <- density(traits[as.factor(var.1) == levels(as.factor(var.1))[co],t], na.rm = T)$x
y <- density(traits[as.factor(var.1) == levels(as.factor(var.1))[co],t], na.rm = T)$y
polygon(c(x,rev(x)), c(rep(0,length(x)),rev(y)), border = NA, col = rgb(0.5,0.5,0.5,0.7))
}
#Add a legend
if (leg){
if (mean(traits[as.factor(var.1) == levels(as.factor(var.1))[co],t], na.rm = T) <  mean(traits[,t], na.rm = T) ) {pos = "topright"}
else{pos = "topleft"}
legend(pos, inset = 0.05, levels(as.factor(var.2)), fill = col.dens, cex = cex.leg, bty = "n", ncol = round(sqrt(nlevels(as.factor((var.2))))-1))
}
#Plot the distribution by the factor 2
for(s in 1:nlevels(as.factor(var.2))) {
if (length(na.omit(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t]))>1)
{lines(density(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t], na.rm = T), col = col.dens[s])}
else if (length(na.omit(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t])) == 1)
{points(0,na.omit(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t]), col = col.dens[s])}
}
}
}
}
if(plot.ask | multipanel) {
par(oldpar)
}
}
plotDistri(ex.traits2, rep("region", times = dim(ex.traits2)[1]), ex.sp2, plot.ask = F,
multipanel = F, xlim=c(0,0.2))
plotDistri(ex.traits2, rep("region", times = dim(ex.traits2)[1]), ex.sp2, plot.ask = F,
multipanel = F, xlim=c(0,0.02))
plotDistri(ex.traits2, rep("region", times = dim(ex.traits2)[1]), ex.sp2, plot.ask = F,
multipanel = F, ylim=c(0,0.02))
plotDistri(ex.traits2, rep("region", times = dim(ex.traits2)[1]), ex.sp2, plot.ask = F,
multipanel = F, ylim=c(0,0.04))
plotDistri(ex.traits2, rep("toutes_sp", times = dim(ex.traits2)[1]), ex.indplot2,
plot.ask = F, multipanel = F)
plotDistri(ex.traits2, rep("region", times = dim(ex.traits2)[1]), ex.sp2, plot.ask = F,
multipanel = F, ylim=c(0,0.04))
plotDistri(ex.traits2, rep("toutes_sp", times = dim(ex.traits2)[1]), ex.indplot2,
plot.ask = F, multipanel = F)
plotDistri <- function(traits = NULL, var.1 = NULL, var.2 = NULL, col.dens = NULL, plot.ask = TRUE, ylim.cex = 1, cex.leg = 0.8, polyg = TRUE, multipanel = TRUE, leg = TRUE, xlim = NULL, ylim = NULL) {
var.1 <- as.factor(as.vector(var.1))
var.2 <- as.factor(as.vector(var.2))
namestraits <- colnames(traits)
namescommunity <- unique(var.1)
ncom <- length(namescommunity)
ntr <- dim(as.matrix(traits))[2]
if (is.null(col.dens)) {col.dens <- funky.col(nlevels(as.factor(var.2)))}
#Graphical parameters
if(plot.ask | multipanel) {
oldpar <- par(no.readonly = TRUE)
}
par(ask = plot.ask)
if (multipanel) {
par(mfrow = c(2,2))
}
for(co in 1:ncom){
for(t in 1:ntr){
if (length(na.omit(traits[as.factor(var.1) == levels(as.factor(var.1))[co],t]))>1){
#______
#Define the limit for the plot
xli.interm <- c()
yli.interm <- c()
xlimin.interm <- c()
ylimin.interm <- c()
for(s in 1:nlevels(as.factor(var.2))) {
if (length(na.omit(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t]))>1) {
xli.interm[s] <- max(density(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t], na.rm = T)$x, na.rm = TRUE)
yli.interm[s] <- max(density(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t], na.rm = T)$y, na.rm = TRUE)
xlimin.interm[s] <- min(density(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t], na.rm = T)$x, na.rm = TRUE)
ylimin.interm[s] <- min(density(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t], na.rm = T)$y, na.rm = TRUE)
}
}
if(is.null(xlim)){
xli <- max(xli.interm, na.rm = TRUE)
xlimin <- min(xlimin.interm, na.rm = TRUE)
xlim = c(min(c(min(density(traits[,t], na.rm = T)$x), xlimin)), max(c(max(density(traits[,t], na.rm = T)$x, na.rm = T), xli)))
}
if(is.null(ylim)){
yli <- max(yli.interm, na.rm = TRUE)
ylimin <- min(ylimin.interm, na.rm = TRUE)
ylim = c(min(c(min(density(traits[,t], na.rm = T)$y), ylimin)), max(c(max(density(traits[,t], na.rm = T)$y, na.rm = T), yli))*1.08)
}
#______
#Plot the regional distribution
plot(main = paste(namestraits[t],levels(as.factor(var.1))[co], " "), density(traits[as.factor(var.1) == levels(as.factor(var.1))[co],t], na.rm = T), ylim = ylim, xlim = xlim, col = "black")
lines(density(traits[,t], na.rm = T), lty = 2, col = "grey")
if (polyg == T) {
x <- density(traits[as.factor(var.1) == levels(as.factor(var.1))[co],t], na.rm = T)$x
y <- density(traits[as.factor(var.1) == levels(as.factor(var.1))[co],t], na.rm = T)$y
polygon(c(x,rev(x)), c(rep(0,length(x)),rev(y)), border = NA, col = rgb(0.5,0.5,0.5,0.7))
}
#______
#Add a legend
if (leg){
if (mean(traits[as.factor(var.1) == levels(as.factor(var.1))[co],t], na.rm = T) <  mean(traits[,t], na.rm = T) ) {pos = "topright"}
else{pos = "topleft"}
legend(pos, inset = 0.05, levels(as.factor(var.2)), fill = col.dens, cex = cex.leg, bty = "n", ncol = round(sqrt(nlevels(as.factor((var.2))))-1))
}
#______
#Plot the distribution by the factor 2
for(s in 1:nlevels(as.factor(var.2))) {
if (length(na.omit(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t]))>1)
{lines(density(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t], na.rm = T), col = col.dens[s])}
else if (length(na.omit(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t])) == 1)
{points(0,na.omit(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t]), col = col.dens[s])}
}
}
}
}
if(plot.ask | multipanel) {
par(oldpar)
}
}
plotDistri(ex.traits2, rep("toutes_sp", times = dim(ex.traits2)[1]), ex.indplot2,
plot.ask = F, multipanel = F)
plotDistri <- function(traits = NULL, var.1 = NULL, var.2 = NULL, col.dens = NULL, plot.ask = TRUE, ylim.cex = 1, cex.leg = 0.8, polyg = TRUE, multipanel = TRUE, leg = TRUE, xlim = NULL, ylim = NULL) {
var.1 <- as.factor(as.vector(var.1))
var.2 <- as.factor(as.vector(var.2))
namestraits <- colnames(traits)
namescommunity <- unique(var.1)
ncom <- length(namescommunity)
ntr <- dim(as.matrix(traits))[2]
if (is.null(col.dens)) {col.dens <- funky.col(nlevels(as.factor(var.2)))}
#Graphical parameters
if(plot.ask | multipanel) {
oldpar <- par(no.readonly = TRUE)
}
par(ask = plot.ask)
if (multipanel) {
par(mfrow = c(2,2))
}
for(co in 1:ncom){
for(t in 1:ntr){
if (length(na.omit(traits[as.factor(var.1) == levels(as.factor(var.1))[co],t]))>1){
#______
#Define the limit for the plot
xli.interm <- c()
yli.interm <- c()
xlimin.interm <- c()
ylimin.interm <- c()
for(s in 1:nlevels(as.factor(var.2))) {
if (length(na.omit(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t]))>1) {
xli.interm[s] <- max(density(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t], na.rm = T)$x, na.rm = TRUE)
yli.interm[s] <- max(density(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t], na.rm = T)$y, na.rm = TRUE)
xlimin.interm[s] <- min(density(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t], na.rm = T)$x, na.rm = TRUE)
ylimin.interm[s] <- min(density(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t], na.rm = T)$y, na.rm = TRUE)
}
}
if(is.null(xlim)){
xli <- max(xli.interm, na.rm = TRUE)
xlimin <- min(xlimin.interm, na.rm = TRUE)
xlim = c(min(c(min(density(traits[,t], na.rm = T)$x), xlimin)), max(c(max(density(traits[,t], na.rm = T)$x, na.rm = T), xli)))
}
if(is.null(ylim)){
yli <- max(yli.interm, na.rm = TRUE)
ylimin <- min(ylimin.interm, na.rm = TRUE)
ylim = c(min(c(min(density(traits[,t], na.rm = T)$y), ylimin)), max(c(max(density(traits[,t], na.rm = T)$y, na.rm = T), yli))*1.05)
}
#______
#Plot the regional distribution
plot(main = paste(namestraits[t],levels(as.factor(var.1))[co], " "), density(traits[as.factor(var.1) == levels(as.factor(var.1))[co],t], na.rm = T), ylim = ylim, xlim = xlim, col = "black")
lines(density(traits[,t], na.rm = T), lty = 2, col = "grey")
if (polyg == T) {
x <- density(traits[as.factor(var.1) == levels(as.factor(var.1))[co],t], na.rm = T)$x
y <- density(traits[as.factor(var.1) == levels(as.factor(var.1))[co],t], na.rm = T)$y
polygon(c(x,rev(x)), c(rep(0,length(x)),rev(y)), border = NA, col = rgb(0.5,0.5,0.5,0.7))
}
#______
#Add a legend
if (leg){
if (mean(traits[as.factor(var.1) == levels(as.factor(var.1))[co],t], na.rm = T) <  mean(traits[,t], na.rm = T) ) {pos = "topright"}
else{pos = "topleft"}
legend(pos, inset = 0.05, levels(as.factor(var.2)), fill = col.dens, cex = cex.leg, bty = "n", ncol = round(sqrt(nlevels(as.factor((var.2))))-1))
}
#______
#Plot the distribution by the factor 2
for(s in 1:nlevels(as.factor(var.2))) {
if (length(na.omit(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t]))>1)
{lines(density(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t], na.rm = T), col = col.dens[s])}
else if (length(na.omit(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t])) == 1)
{points(0,na.omit(traits[as.factor(var.1) == levels(as.factor(var.1))[co] & as.factor(var.2) == levels(as.factor(var.2))[s],t]), col = col.dens[s])}
}
}
}
}
if(plot.ask | multipanel) {
par(oldpar)
}
}
plotDistri(ex.traits2, rep("toutes_sp", times = dim(ex.traits2)[1]), ex.indplot2,
plot.ask = F, multipanel = F)
plotDistri(ex.traits2, rep("region", times = dim(ex.traits2)[1]), ex.sp2, plot.ask = F,
multipanel = F, ylim=c(0,0.04))
plotDistri(ex.traits2, rep("region", times = dim(ex.traits2)[1]), ex.sp2, plot.ask = F,
multipanel = F, ylim = c(0,0.04), cex.leg = 0.2)
plotDistri(ex.traits2, rep("region", times = dim(ex.traits2)[1]), ex.sp2, plot.ask = F,
multipanel = F, ylim = c(0,0.04), cex.leg = 0.4)
plotDistri(ex.traits2, rep("toutes_sp", times = dim(ex.traits2)[1]), ex.indplot2,
plot.ask = F, multipanel = F)
plotDistri(ex.traits2, rep("toutes_sp", times = dim(ex.traits2)[1]), ex.indplot2,
plot.ask = F, multipanel = F, cex.leg = 0.6)
plotDistri(ex.traits2, rep("region", times = dim(ex.traits2)[1]), ex.sp2, plot.ask = F,
multipanel = F, ylim = c(0,0.04), cex.leg = 0.35)
plotDistri(ex.traits2, rep("region", times = dim(ex.traits2)[1]), ex.sp2, plot.ask = F,
multipanel = F, ylim = c(0,0.04), cex.leg = 0.6)
cor.test(param_range, modeled_param_norm)
cor.test(param_range, modeled_param_norm)[1]
cor.test(param_range, modeled_param_norm)[2]
cor.test(param_range, modeled_param_norm)[3]
cor.test(param_range, modeled_param_norm)[4]
install.packages("~/Desktop/cati/pkg/cati_0.94.tar.gz", repos = NULL, type = "source")
round(cor.test(param_range, modeled_param_norm)[4], 3)
cor.test(param_range, modeled_param_norm)[4]
cor.test(param_range, modeled_param_norm)[[4]]
install.packages("~/Desktop/cati/pkg/cati_0.94.tar.gz", repos = NULL, type = "source")
R
R.version
par(mfrow=c(2, 1))
plot(res.simu2[[1]])
plot(res.simu2[[nperm]])
par(mfrow=c(1, 1))
library(cati)
library(cati)
data(finch.ind)
traits=traits.finch
div_range = FALSE; na.rm = FALSE; scale.tr = TRUE; method.dist = "euclidian"
#Uni-traits vector transforme to a matrix
if(!is.matrix(traits)){
traits <- na.omit(traits)
traits <- as.matrix(traits, ncol = 1)
}
#Calcul of nearest neighbourhood distance
if(scale.tr) {
traits <- apply(traits, 2, scale)
}
mat.dist <- dist(traits, method = method.dist)
nnd <- apply(as.matrix(mat.dist), 1, function(x) min (x[x>0]))
mat.dist <- dist(traits, method = method.dist)
nnd <- apply(as.matrix(mat.dist), 1, function(x) min (x))
ptm <- proc.time()
mat.dist <- dist(traits, method = method.dist)
nnd <- apply(as.matrix(mat.dist), 1, function(x) min (x[x>0]))
#Metric calculation
CVNND <- sd(nnd[is.finite(nnd)], na.rm = T)/mean(nnd[is.finite(nnd)], na.rm = T)
if (div_range) {
CVNND <- CVNND/(max(traits, na.rm = na.rm) - min(traits, na.rm = na.rm) )
}
else {}
proc.time1 <- proc.time() - ptm
ptm <- proc.time()
mat.dist <- dist(traits, method = method.dist)
nnd <- apply(as.matrix(mat.dist), 1, function(x) min (x))
#Metric calculation
CVNND <- sd(nnd[is.finite(nnd)], na.rm = T)/mean(nnd[is.finite(nnd)], na.rm = T)
if (div_range) {
CVNND <- CVNND/(max(traits, na.rm = na.rm) - min(traits, na.rm = na.rm) )
}
else {}
proc.time2 <- proc.time() - ptm
proc.time1
proc.time2
traits<-traits.finch[1,]
traits
traits<-traits.finch[,1]
#Uni-traits vector transforme to a matrix
if(!is.matrix(traits)){
traits <- na.omit(traits)
traits <- as.matrix(traits, ncol = 1)
}
#Calcul of nearest neighbourhood distance
if(scale.tr) {
traits <- apply(traits, 2, scale)
}
mat.dist <- dist(traits, method = method.dist)
nnd <- apply(as.matrix(mat.dist), 1, function(x) min (x[x>0]))
#Metric calculation
CVNND <- sd(nnd[is.finite(nnd)], na.rm = T)/mean(nnd[is.finite(nnd)], na.rm = T)
if (div_range) {
CVNND <- CVNND/(max(traits, na.rm = na.rm) - min(traits, na.rm = na.rm) )
}
CVNND <- function(traits, div_range = FALSE, na.rm = FALSE, scale.tr = TRUE, method.dist = "euclidian"){
#Uni-traits vector transforme to a matrix
if(!is.matrix(traits)){
traits <- na.omit(traits)
traits <- as.matrix(traits, ncol = 1)
}
#Calcul of nearest neighbourhood distance
if(scale.tr) {
traits <- apply(traits, 2, scale)
}
mat.dist <- dist(traits, method = method.dist)
nnd <- apply(as.matrix(mat.dist), 1, function(x) min (x[x>0]))
#Metric calculation
CVNND <- sd(nnd[is.finite(nnd)], na.rm = T)/mean(nnd[is.finite(nnd)], na.rm = T)
if (div_range) {
CVNND <- CVNND/(max(traits, na.rm = na.rm) - min(traits, na.rm = na.rm) )
}
else {}
return(CVNND)
}
ptm <- proc.time()
CVNND (traits.finch[,1])
proc.time1 <- proc.time() - ptm
ptm <- proc.time()
CVNND (traits.finch)
proc.time1.multi <- proc.time() - ptm
ptm <- proc.time()
CVNND (traits.finch[,1], scale.tr = F)
proc.time2 <- proc.time() - ptm
ptm <- proc.time()
CVNND (traits.finch, scale.tr = F)
proc.time2.multi <- proc.time() - ptm
ptm <- proc.time()
CVNND (traits.finch[,1], div_range=T)
proc.time3 <- proc.time() - ptm
ptm <- proc.time()
CVNND (traits.finch, div_range=T)
proc.time3.multi <- proc.time() - ptm
proc.time1
proc.time1
proc.time1.multi
proc.time1
proc.time1.multi
proc.time2
proc.time2.multi
proc.time3
proc.time3.multi
CVNND <- function(traits, div_range = FALSE, na.rm = FALSE, scale.tr = TRUE, method.dist = "euclidian"){
#Uni-traits vector transforme to a matrix
if(!is.matrix(traits)){
traits <- na.omit(traits)
traits <- as.matrix(traits, ncol = 1)
}
#Calcul of nearest neighbourhood distance
if(scale.tr) {
traits <- apply(traits, 2, scale)
}
mat.dist <- dist(traits, method = method.dist)
nnd <- apply(as.matrix(mat.dist), 1, function(x) min (x[x>0]))
#Metric calculation
CVNND <- sd(nnd[is.finite(nnd)], na.rm = T)/mean(nnd[is.finite(nnd)], na.rm = T)
if (div_range) {
CVNND <- CVNND/(max(traits, na.rm = na.rm) - min(traits, na.rm = na.rm) )
}
else {}
return(CVNND)
}
proc.time1
proc.time1.multi
proc.time2
proc.time2.multi
proc.time3
proc.time3.multi
proc.time1/proc.time1.multi
traits <- na.omit(traits)
traits<-traits.finch[,1]
traits <- na.omit(traits)
if(!is.matrix(traits)){
traits <- na.omit(traits)
traits <- as.matrix(traits, ncol = 1)
}
traits
mat.dist <- dist(traits, method = method.dist)
nnd <- apply(as.matrix(mat.dist), 1, function(x) min (x[x>0]))
nnd
mat.dist <- dist(traits.finch, method = method.dist)
nnd <- apply(as.matrix(mat.dist), 1, function(x) min (x[x>0]))
!is.matrix(traits)
system.time{CVNND (traits.finch[,1])}
system.time(CVNND (traits.finch[,1]))
system.time(for(i in 1:100) mad(runif(1000)))
exT <- function(n = 10000) {
# Purpose: Test if system.time works ok;   n: loop size
system.time(for(i in 1:n) x <- mean(rt(1000, df = 4)))
}
exT()
system.time(exT())
mat.dist <- dist(traits, method = method.dist)
traits<-traits.finch
ptm <- proc.time()
mat.dist <- dist(traits[,1], method = method.dist)
nnd <- apply(as.matrix(mat.dist), 1, function(x) min (x[x>0]))
proc.time1 <- proc.time() - ptm
ptm <- proc.time()
mat.dist <- dist(traits, method = method.dist)
nnd <- apply(as.matrix(mat.dist), 1, function(x) min (x[x>0]))
proc.time1.multi <- proc.time() - ptm
proc.time1
proc.time1.multi
proc.time2.multi
CVNND (traits.finch, scale.tr = F)
CVNND (traits.finch[,1], scale.tr = F)
nnd
data(finch.ind)
ptm <- proc.time()
mat.dist <- dist(traits[,1], method = method.dist)
nnd <- apply(as.matrix(mat.dist), 1, function(x) min (x[x>0]))
proc.time1 <- proc.time() - ptm
div_range = FALSE; na.rm = FALSE; scale.tr = TRUE; method.dist = "euclidian"
ptm <- proc.time()
mat.dist <- dist(traits[,1], method = method.dist)
nnd <- apply(as.matrix(mat.dist), 1, function(x) min (x[x>0]))
proc.time1 <- proc.time() - ptm
traits<-traits.finch
div_range = FALSE; na.rm = FALSE; scale.tr = TRUE; method.dist = "euclidian"
ptm <- proc.time()
mat.dist <- dist(traits[,1], method = method.dist)
nnd <- apply(as.matrix(mat.dist), 1, function(x) min (x[x>0]))
proc.time1 <- proc.time() - ptm
ptm <- proc.time()
mat.dist <- dist(traits, method = method.dist)
nnd <- apply(as.matrix(mat.dist), 1, function(x) min (x[x>0]))
proc.time1.multi <- proc.time() - ptm
ptm <- proc.time()
CVNND (traits.finch[,1], scale.tr = F)
proc.time2 <- proc.time() - ptm
require(cati)
ptm <- proc.time()
CVNND (traits.finch[,1], scale.tr = F)
proc.time2 <- proc.time() - ptm
ptm <- proc.time()
CVNND (traits.finch, scale.tr = F)
proc.time2.multi <- proc.time() - ptm
proc.time2.multi
proc.time1.multi
apply(as.matrix(mat.dist), 1, function(x) min (x[x>0]))
apply(as.matrix(mat.dist), 1, function(x) min(x)[min(x)!=0])
apply(as.matrix(mat.dist), 1, function(x) min (x))
apply(as.matrix(mat.dist), 1, function(x) min(x)[min(x)!=0])
apply(as.matrix(mat.dist), 1, function(x) min (x[x>0]))
?dist
mat.dist <- dist(traits, method = method.dist)
mat.dist
diag = FALSE
mat.dist <- as.matrix(dist(traits, method = method.dist))
head(mat.dist)
(mat.dist)[1:3,1:3]
diag(mat.dist )
diag(mat.dist )<-Na
diag(mat.dist )<- 5
(mat.dist)[1:3,1:3]
diag(mat.dist )
diag(mat.dist )<- "NA"
mat.dist[1:3,1:3]
diag(mat.dist )<- NA
mat.dist[1:3,1:3]
mat.dist <- as.matrix(dist(traits, method = method.dist))
diag(mat.dist )<- NA
mat.dist[1:3,1:3]
mat.dist <- as.matrix(dist(traits, method = method.dist))
diag(mat.dist )<- NA
nnd <- apply(mat.dist, 1, function(x) min (x))
CVNND2 <- function(traits, div_range = FALSE, na.rm = FALSE, scale.tr = TRUE, method.dist = "euclidian"){
#Uni-traits vector transforme to a matrix
if(!is.matrix(traits)){
traits <- na.omit(traits)
traits <- as.matrix(traits, ncol = 1)
}
#Calcul of nearest neighbourhood distance
if(scale.tr) {
traits <- apply(traits, 2, scale)
}
mat.dist <- as.matrix(dist(traits, method = method.dist))
diag(mat.dist )<- NA
nnd <- apply(mat.dist, 1, function(x) min (x))
#Metric calculation
CVNND <- sd(nnd[is.finite(nnd)], na.rm = T)/mean(nnd[is.finite(nnd)], na.rm = T)
if (div_range) {
CVNND <- CVNND/(max(traits, na.rm = na.rm) - min(traits, na.rm = na.rm) )
}
else {}
return(CVNND)
}
system.time(CVNND (traits.finch[,1]))
system.time(CVNND (traits.finch[,1]))
system.time(CVNND2 (traits.finch))
system.time(CVNND2 (traits.finch))
8.5*2
3
10
5.5
8.5*2+3+10+15.5
8.5*2+13
>>>>>>> da4a64abb7861c211f4b13b00d2566b05cc7c20b
library(cati)
