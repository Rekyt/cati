if (length(dim(obs)) != 2 ) {
obs <- t(as.matrix(obs))
}
if (dim(obs)[1] == dim(obs)[2]) {
warnings("Observed matrix have the same number of rows and columns. The function is not able to detect automatically the correspondance between dimension of observed matrix and null model. You need to be sure that the null model is in the form of an array within the first and second dimension corresespond respectively to the first and second dimension of the observed matrix and the third dimension correspond to permutations")
cond = c(1,2)
}
if (dim(obs)[1] != dim(obs)[2]) {
if (class(nullmodel) == "list"){
if (class(nullmodel[[1]]) == "list"){
nullmodel <- array(unlist(nullmodel), dim = c(nrow(nullmodel[[1]][[1]]),ncol(nullmodel[[1]][[1]]), length(unlist(nullmodel))/nrow(nullmodel[[1]][[1]])/ncol(nullmodel[[1]][[1]])))
}
else {nullmodel <- array(unlist(nullmodel), dim = c(nrow(nullmodel[[1]]),ncol(nullmodel[[1]]), length(unlist(nullmodel))/nrow(nullmodel[[1]])/ncol(nullmodel[[1]])))}
}
if (class(obs) == "list"){
obs <- matrix(obs[[1]], nrow = nrow(obs[[1]]), ncol = ncol(obs[[1]]))
}
if (!is.null(dim(obs))) {
cond <- c(NA,NA)
if (dim(obs)[1] == dim(nullmodel)[1]){
cond[1] <- 1
}
if (dim(obs)[1] == dim(nullmodel)[2]){
cond[1] <- 2
}
if (length(dim(nullmodel)) == 3){
if (dim(obs)[1] == dim(nullmodel)[3]){
cond[1] <- 3
}
}
if (dim(obs)[2] == dim(nullmodel)[1]){
cond[2] <- 1
}
if (dim(obs)[2] == dim(nullmodel)[2]){
cond[2] <- 2
}
if (length(dim(nullmodel)) == 3){
if (dim(obs)[2] == dim(nullmodel)[3]){
cond[2] <- 3
}
}
}
}
cond <- na.omit(cond)
nullmodel <- aperm(nullmodel, c(cond, (1:3)[!1:3 %in% cond]))
ni_tot <- names(x[[1]])[t]
if(is.null(ni_tot)){
ni_tot <- dimnames(x[[1]])[[2]][t]
}
res[[eval(names(x[i]))]] <- list()
for(t in 1:length(eval(ni_tot))){
ni <- names(x[[i]])[t]
if(is.null(ni)){
ni <- dimnames(x[[i]])[[2]][t]
}
res[[eval(names(x[i]))]][[eval(ni)]] <- list()
for(g in 1:length(obs[,t])){
res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf[g] <- (1 + sum(obs[g,t] < nullmodel [g,t,], na.rm = T)) / (dim(nullmodel)[3] + 1)
res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup[g] <- (1 + sum(obs[g,t] > nullmodel [g,t,], na.rm = T)) / (dim(nullmodel)[3] + 1)
}
if(!is.null(dimnames(x[[1]])[[1]])){
res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf <- cbind(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf)
rownames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf) <- dimnames(x[[1]])[[1]]
colnames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf) <- dimnames(x[[1]])[[2]][t]
res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup <- cbind(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup)
rownames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup) <- dimnames(x[[1]])[[1]]
colnames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup) <- dimnames(x[[1]])[[2]][t]
}
}
}
return(res)
Pval(res.finch)
res
rm(res)
if (!inherits(x, "listofindex")){
x <- as.listofindex(x)
}
res <- list()
for (i in seq(1, length(x), 2)){
obs <- x[[i]]
nullmodel <- x[[i+1]]
if (is.vector(obs)){
obs <- t(as.matrix(obs))
}
if (length(dim(obs)) != 2 ) {
obs <- t(as.matrix(obs))
}
if (dim(obs)[1] == dim(obs)[2]) {
warnings("Observed matrix have the same number of rows and columns. The function is not able to detect automatically the correspondance between dimension of observed matrix and null model. You need to be sure that the null model is in the form of an array within the first and second dimension corresespond respectively to the first and second dimension of the observed matrix and the third dimension correspond to permutations")
cond = c(1,2)
}
if (dim(obs)[1] != dim(obs)[2]) {
if (class(nullmodel) == "list"){
if (class(nullmodel[[1]]) == "list"){
nullmodel <- array(unlist(nullmodel), dim = c(nrow(nullmodel[[1]][[1]]),ncol(nullmodel[[1]][[1]]), length(unlist(nullmodel))/nrow(nullmodel[[1]][[1]])/ncol(nullmodel[[1]][[1]])))
}
else {nullmodel <- array(unlist(nullmodel), dim = c(nrow(nullmodel[[1]]),ncol(nullmodel[[1]]), length(unlist(nullmodel))/nrow(nullmodel[[1]])/ncol(nullmodel[[1]])))}
}
if (class(obs) == "list"){
obs <- matrix(obs[[1]], nrow = nrow(obs[[1]]), ncol = ncol(obs[[1]]))
}
if (!is.null(dim(obs))) {
cond <- c(NA,NA)
if (dim(obs)[1] == dim(nullmodel)[1]){
cond[1] <- 1
}
if (dim(obs)[1] == dim(nullmodel)[2]){
cond[1] <- 2
}
if (length(dim(nullmodel)) == 3){
if (dim(obs)[1] == dim(nullmodel)[3]){
cond[1] <- 3
}
}
if (dim(obs)[2] == dim(nullmodel)[1]){
cond[2] <- 1
}
if (dim(obs)[2] == dim(nullmodel)[2]){
cond[2] <- 2
}
if (length(dim(nullmodel)) == 3){
if (dim(obs)[2] == dim(nullmodel)[3]){
cond[2] <- 3
}
}
}
}
cond <- na.omit(cond)
nullmodel <- aperm(nullmodel, c(cond, (1:3)[!1:3 %in% cond]))
ni_tot <- names(x[[1]])[t]
if(is.null(ni_tot)){
ni_tot <- dimnames(x[[1]])[[2]][t]
}
res[[eval(names(x[i]))]] <- list()
for(t in 1:length(eval(ni_tot))){
ni <- names(x[[i]])[t]
if(is.null(ni)){
ni <- dimnames(x[[i]])[[2]][t]
}
res[[eval(names(x[i]))]][[eval(ni)]] <- list()
for(g in 1:length(obs[,t])){
res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf[g] <- (1 + sum(obs[g,t] < nullmodel [g,t,], na.rm = T)) / (dim(nullmodel)[3] + 1)
res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup[g] <- (1 + sum(obs[g,t] > nullmodel [g,t,], na.rm = T)) / (dim(nullmodel)[3] + 1)
}
if(!is.null(dimnames(x[[1]])[[1]])){
res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf <- cbind(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf)
rownames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf) <- dimnames(x[[1]])[[1]]
colnames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf) <- dimnames(x[[1]])[[2]][t]
res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup <- cbind(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup)
rownames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup) <- dimnames(x[[1]])[[1]]
colnames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup) <- dimnames(x[[1]])[[2]][t]
}
}
}
res
Pval <- function (x, na.rm = TRUE) {
if (!inherits(x, "listofindex")){
x <- as.listofindex(x)
}
res <- list()
for (i in seq(1, length(x), 2)){
obs <- x[[i]]
nullmodel <- x[[i+1]]
if (is.vector(obs)){
obs <- t(as.matrix(obs))
}
if (length(dim(obs)) != 2 ) {
obs <- t(as.matrix(obs))
}
if (dim(obs)[1] == dim(obs)[2]) {
warnings("Observed matrix have the same number of rows and columns. The function is not able to detect automatically the correspondance between dimension of observed matrix and null model. You need to be sure that the null model is in the form of an array within the first and second dimension corresespond respectively to the first and second dimension of the observed matrix and the third dimension correspond to permutations")
cond = c(1,2)
}
if (dim(obs)[1] != dim(obs)[2]) {
if (class(nullmodel) == "list"){
if (class(nullmodel[[1]]) == "list"){
nullmodel <- array(unlist(nullmodel), dim = c(nrow(nullmodel[[1]][[1]]),ncol(nullmodel[[1]][[1]]), length(unlist(nullmodel))/nrow(nullmodel[[1]][[1]])/ncol(nullmodel[[1]][[1]])))
}
else {nullmodel <- array(unlist(nullmodel), dim = c(nrow(nullmodel[[1]]),ncol(nullmodel[[1]]), length(unlist(nullmodel))/nrow(nullmodel[[1]])/ncol(nullmodel[[1]])))}
}
if (class(obs) == "list"){
obs <- matrix(obs[[1]], nrow = nrow(obs[[1]]), ncol = ncol(obs[[1]]))
}
if (!is.null(dim(obs))) {
cond <- c(NA,NA)
if (dim(obs)[1] == dim(nullmodel)[1]){
cond[1] <- 1
}
if (dim(obs)[1] == dim(nullmodel)[2]){
cond[1] <- 2
}
if (length(dim(nullmodel)) == 3){
if (dim(obs)[1] == dim(nullmodel)[3]){
cond[1] <- 3
}
}
if (dim(obs)[2] == dim(nullmodel)[1]){
cond[2] <- 1
}
if (dim(obs)[2] == dim(nullmodel)[2]){
cond[2] <- 2
}
if (length(dim(nullmodel)) == 3){
if (dim(obs)[2] == dim(nullmodel)[3]){
cond[2] <- 3
}
}
}
}
cond <- na.omit(cond)
nullmodel <- aperm(nullmodel, c(cond, (1:3)[!1:3 %in% cond]))
ni_tot <- names(x[[1]])[t]
if(is.null(ni_tot)){
ni_tot <- dimnames(x[[1]])[[2]][t]
}
res[[eval(names(x[i]))]] <- list()
for(t in 1:length(eval(ni_tot))){
ni <- names(x[[i]])[t]
if(is.null(ni)){
ni <- dimnames(x[[i]])[[2]][t]
}
res[[eval(names(x[i]))]][[eval(ni)]] <- list()
for(g in 1:length(obs[,t])){
res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf[g] <- (1 + sum(obs[g,t] < nullmodel [g,t,], na.rm = T)) / (dim(nullmodel)[3] + 1)
res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup[g] <- (1 + sum(obs[g,t] > nullmodel [g,t,], na.rm = T)) / (dim(nullmodel)[3] + 1)
}
if(!is.null(dimnames(x[[1]])[[1]])){
res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf <- cbind(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf)
rownames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf) <- dimnames(x[[1]])[[1]]
colnames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf) <- dimnames(x[[1]])[[2]][t]
res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup <- cbind(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup)
rownames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup) <- dimnames(x[[1]])[[1]]
colnames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup) <- dimnames(x[[1]])[[2]][t]
}
}
}
return(res)
}
Pval <- function (x, na.rm = TRUE) {
if (!inherits(x, "listofindex")){
x <- as.listofindex(x)
}
res <- list()
for (i in seq(1, length(x), 2)){
obs <- x[[i]]
nullmodel <- x[[i+1]]
if (is.vector(obs)){
obs <- t(as.matrix(obs))
}
if (length(dim(obs)) != 2 ) {
obs <- t(as.matrix(obs))
}
if (dim(obs)[1] == dim(obs)[2]) {
warnings("Observed matrix have the same number of rows and columns. The function is not able to detect automatically the correspondance between dimension of observed matrix and null model. You need to be sure that the null model is in the form of an array within the first and second dimension corresespond respectively to the first and second dimension of the observed matrix and the third dimension correspond to permutations")
cond = c(1,2)
}
if (dim(obs)[1] != dim(obs)[2]) {
if (class(nullmodel) == "list"){
if (class(nullmodel[[1]]) == "list"){
nullmodel <- array(unlist(nullmodel), dim = c(nrow(nullmodel[[1]][[1]]),ncol(nullmodel[[1]][[1]]), length(unlist(nullmodel))/nrow(nullmodel[[1]][[1]])/ncol(nullmodel[[1]][[1]])))
}
else {nullmodel <- array(unlist(nullmodel), dim = c(nrow(nullmodel[[1]]),ncol(nullmodel[[1]]), length(unlist(nullmodel))/nrow(nullmodel[[1]])/ncol(nullmodel[[1]])))}
}
if (class(obs) == "list"){
obs <- matrix(obs[[1]], nrow = nrow(obs[[1]]), ncol = ncol(obs[[1]]))
}
if (!is.null(dim(obs))) {
cond <- c(NA,NA)
if (dim(obs)[1] == dim(nullmodel)[1]){
cond[1] <- 1
}
if (dim(obs)[1] == dim(nullmodel)[2]){
cond[1] <- 2
}
if (length(dim(nullmodel)) == 3){
if (dim(obs)[1] == dim(nullmodel)[3]){
cond[1] <- 3
}
}
if (dim(obs)[2] == dim(nullmodel)[1]){
cond[2] <- 1
}
if (dim(obs)[2] == dim(nullmodel)[2]){
cond[2] <- 2
}
if (length(dim(nullmodel)) == 3){
if (dim(obs)[2] == dim(nullmodel)[3]){
cond[2] <- 3
}
}
}
}
cond <- na.omit(cond)
nullmodel <- aperm(nullmodel, c(cond, (1:3)[!1:3 %in% cond]))
ni_tot <- names(x[[1]])[t]
if(is.null(ni_tot)){
ni_tot <- dimnames(x[[1]])[[2]][t]
}
res[[eval(names(x[i]))]] <- list()
for(t in 1:length(eval(ni_tot))){
ni <- names(x[[i]])[t]
if(is.null(ni)){
ni <- dimnames(x[[i]])[[2]][t]
}
res[[eval(names(x[i]))]][[eval(ni)]] <- list()
for(g in 1:length(obs[,t])){
res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf[g] <- (1 + sum(obs[g,t] < nullmodel [g,t,], na.rm = T)) / (dim(nullmodel)[3] + 1)
res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup[g] <- (1 + sum(obs[g,t] > nullmodel [g,t,], na.rm = T)) / (dim(nullmodel)[3] + 1)
}
if(!is.null(dimnames(x[[1]])[[1]])){
res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf <- cbind(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf)
rownames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf) <- dimnames(x[[1]])[[1]]
colnames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf) <- dimnames(x[[1]])[[2]][t]
res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup <- cbind(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup)
rownames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup) <- dimnames(x[[1]])[[1]]
colnames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup) <- dimnames(x[[1]])[[2]][t]
}
}
}
return(res)
}
Pval(res.finch)
library(cati)
Pval(res.finch)
??Pval
data(finch.ind)
res.finch <- Tstats(traits.finch, ind.plot = ind.plot.finch,
sp = sp.finch, nperm = 9, print = FALSE)
Pval(res.finch)
Pval(res.finch)
Pval <- function (x, na.rm = TRUE) {
if (!inherits(x, "listofindex")){
x <- as.listofindex(x)
}
res <- list()
for (i in seq(1, length(x), 2)){
obs <- x[[i]]
nullmodel <- x[[i+1]]
if (is.vector(obs)){
obs <- t(as.matrix(obs))
}
if (length(dim(obs)) != 2 ) {
obs <- t(as.matrix(obs))
}
if (dim(obs)[1] == dim(obs)[2]) {
warnings("Observed matrix have the same number of rows and columns. The function is not able to detect automatically the correspondance between dimension of observed matrix and null model. You need to be sure that the null model is in the form of an array within the first and second dimension corresespond respectively to the first and second dimension of the observed matrix and the third dimension correspond to permutations")
cond = c(1,2)
}
if (dim(obs)[1] != dim(obs)[2]) {
if (class(nullmodel) == "list"){
if (class(nullmodel[[1]]) == "list"){
nullmodel <- array(unlist(nullmodel), dim = c(nrow(nullmodel[[1]][[1]]),ncol(nullmodel[[1]][[1]]), length(unlist(nullmodel))/nrow(nullmodel[[1]][[1]])/ncol(nullmodel[[1]][[1]])))
}
else {nullmodel <- array(unlist(nullmodel), dim = c(nrow(nullmodel[[1]]),ncol(nullmodel[[1]]), length(unlist(nullmodel))/nrow(nullmodel[[1]])/ncol(nullmodel[[1]])))}
}
if (class(obs) == "list"){
obs <- matrix(obs[[1]], nrow = nrow(obs[[1]]), ncol = ncol(obs[[1]]))
}
if (!is.null(dim(obs))) {
cond <- c(NA,NA)
if (dim(obs)[1] == dim(nullmodel)[1]){
cond[1] <- 1
}
if (dim(obs)[1] == dim(nullmodel)[2]){
cond[1] <- 2
}
if (length(dim(nullmodel)) == 3){
if (dim(obs)[1] == dim(nullmodel)[3]){
cond[1] <- 3
}
}
if (dim(obs)[2] == dim(nullmodel)[1]){
cond[2] <- 1
}
if (dim(obs)[2] == dim(nullmodel)[2]){
cond[2] <- 2
}
if (length(dim(nullmodel)) == 3){
if (dim(obs)[2] == dim(nullmodel)[3]){
cond[2] <- 3
}
}
}
}
cond <- na.omit(cond)
nullmodel <- aperm(nullmodel, c(cond, (1:3)[!1:3 %in% cond]))
ni_tot <- names(x[[1]])[t]
if(is.null(ni_tot)){
ni_tot <- dimnames(x[[1]])[[2]][t]
}
res[[eval(names(x[i]))]] <- list()
for(t in 1:length(eval(ni_tot))){
ni <- names(x[[i]])[t]
if(is.null(ni)){
ni <- dimnames(x[[i]])[[2]][t]
}
res[[eval(names(x[i]))]][[eval(ni)]] <- list()
for(g in 1:length(obs[,t])){
res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf[g] <- (1 + sum(obs[g,t] < nullmodel [g,t,], na.rm = T)) / (dim(nullmodel)[3] + 1)
res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup[g] <- (1 + sum(obs[g,t] > nullmodel [g,t,], na.rm = T)) / (dim(nullmodel)[3] + 1)
}
if(!is.null(dimnames(x[[1]])[[1]])){
res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf <- cbind(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf)
rownames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf) <- dimnames(x[[1]])[[1]]
res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup <- cbind(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup)
rownames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup) <- dimnames(x[[1]])[[1]]
}
if(!is.null(dimnames(x[[1]])[[2]])){
colnames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup) <- dimnames(x[[1]])[[2]][t]
colnames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf) <- dimnames(x[[1]])[[2]][t]
}
}
}
return(res)
}
Pval(res.finch)
dimnames(x[[1]])[[2]][t]
library(cati)
Pval(res.finch)
#Calcul pvalue for a list of index. This test equates to finding the quantile in exp in which obs would be found (under a one-tailed test)
Pval <- function (x, na.rm = TRUE) {
if (!inherits(x, "listofindex")){
x <- as.listofindex(x)
}
res <- list()
for (i in seq(1, length(x), 2)){
obs <- x[[i]]
nullmodel <- x[[i+1]]
if (is.vector(obs)){
obs <- t(as.matrix(obs))
}
if (length(dim(obs)) != 2 ) {
obs <- t(as.matrix(obs))
}
if (dim(obs)[1] == dim(obs)[2]) {
warnings("Observed matrix have the same number of rows and columns. The function is not able to detect automatically the correspondance between dimension of observed matrix and null model. You need to be sure that the null model is in the form of an array within the first and second dimension corresespond respectively to the first and second dimension of the observed matrix and the third dimension correspond to permutations")
cond = c(1,2)
}
if (dim(obs)[1] != dim(obs)[2]) {
if (class(nullmodel) == "list"){
if (class(nullmodel[[1]]) == "list"){
nullmodel <- array(unlist(nullmodel), dim = c(nrow(nullmodel[[1]][[1]]),ncol(nullmodel[[1]][[1]]), length(unlist(nullmodel))/nrow(nullmodel[[1]][[1]])/ncol(nullmodel[[1]][[1]])))
}
else {nullmodel <- array(unlist(nullmodel), dim = c(nrow(nullmodel[[1]]),ncol(nullmodel[[1]]), length(unlist(nullmodel))/nrow(nullmodel[[1]])/ncol(nullmodel[[1]])))}
}
if (class(obs) == "list"){
obs <- matrix(obs[[1]], nrow = nrow(obs[[1]]), ncol = ncol(obs[[1]]))
}
if (!is.null(dim(obs))) {
cond <- c(NA,NA)
if (dim(obs)[1] == dim(nullmodel)[1]){
cond[1] <- 1
}
if (dim(obs)[1] == dim(nullmodel)[2]){
cond[1] <- 2
}
if (length(dim(nullmodel)) == 3){
if (dim(obs)[1] == dim(nullmodel)[3]){
cond[1] <- 3
}
}
if (dim(obs)[2] == dim(nullmodel)[1]){
cond[2] <- 1
}
if (dim(obs)[2] == dim(nullmodel)[2]){
cond[2] <- 2
}
if (length(dim(nullmodel)) == 3){
if (dim(obs)[2] == dim(nullmodel)[3]){
cond[2] <- 3
}
}
}
}
cond <- na.omit(cond)
nullmodel <- aperm(nullmodel, c(cond, (1:3)[!1:3 %in% cond]))
ni_tot <- names(x[[1]])[1]
if(is.null(ni_tot)){
ni_tot <- dimnames(x[[1]])[[2]][1]
}
res[[eval(names(x[i]))]] <- list()
for(t in 1:length(eval(ni_tot))){
ni <- names(x[[i]])[t]
if(is.null(ni)){
ni <- dimnames(x[[i]])[[2]][t]
}
res[[eval(names(x[i]))]][[eval(ni)]] <- list()
for(g in 1:length(obs[,t])){
res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf[g] <- (1 + sum(obs[g,t] < nullmodel [g,t,], na.rm = T)) / (dim(nullmodel)[3] + 1)
res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup[g] <- (1 + sum(obs[g,t] > nullmodel [g,t,], na.rm = T)) / (dim(nullmodel)[3] + 1)
}
if(!is.null(dimnames(x[[1]])[[1]])){
res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf <- cbind(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf)
rownames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf) <- dimnames(x[[1]])[[1]]
res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup <- cbind(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup)
rownames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup) <- dimnames(x[[1]])[[1]]
}
if(!is.null(dimnames(x[[1]])[[2]][t])){
colnames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.sup) <- dimnames(x[[1]])[[2]][t]
colnames(res[[eval(names(x[i]))]][[eval(ni)]]$pval.inf) <- dimnames(x[[1]])[[2]][t]
}
}
}
return(res)
}
Pval(res.finch)
library(cati)
Pval(res.finch)
data(finch.ind)
res.finch <- Tstats(traits.finch, ind.plot = ind.plot.finch,
sp = sp.finch, nperm = 9, print = FALSE)
Pval(res.finch)
