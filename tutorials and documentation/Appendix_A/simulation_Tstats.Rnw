\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{color, colortbl}
\definecolor{blue1}{RGB}{0,102,204}
\usepackage[colorlinks = true,linkcolor = blue, citecolor = blue, urlcolor = blue]{hyperref}
\usepackage{array}
\usepackage[english]{babel}
\usepackage{amsfonts}
\usepackage{url}
\usepackage{pdflscape}
\usepackage{bm}
\usepackage[margin = 1.5cm]{geometry}
\usepackage[affil-it]{authblk}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage[labelfont = bf]{caption}

\setlength{\doublerulesep}{0pt}
\newcommand{\R}{\mathbb{R}}
\newcommand{\code}[1]{{{\tt #1}}}

\let\oldtabular=\tabular
\def\tabular{\small\oldtabular}

\title{Appendix: Test the T-statistics using simulations: robustness and lack of bias in the function}
\author{Adrien Taudiere\thanks{\texttt{adrien.taudiere@cefe.cnrs.fr}} and Cyrille Violle}

\affil{{\footnotesize CEFE - Centre d'Ecologie Fonctionnelle et Evolutive, Montpellier: France}}

\date{\today}

\sloppy
\hyphenpenalty 10000



%%%%%%% Allow a subsubsub section  %%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}
\makeatletter
\newcounter {subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection .\@arabic\c@subsubsubsection}
\newcommand\subsubsubsection{\@startsection{subsubsubsection}{4}{\z@}%
          {-3.25ex\@plus -1ex \@minus -.2ex}%
          {1.5ex \@plus .2ex}%
          {\normalfont\normalsize\bfseries}}
\renewcommand\paragraph{\@startsection{paragraph}{5}{\z@}%
         {3.25ex \@plus1ex \@minus.2ex}%
         {-1em}%
         {\normalfont\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{6}{\parindent}%
          {3.25ex \@plus1ex \@minus .2ex}%
          {-1em}%
          {\normalfont\normalsize\bfseries}}
\newcommand*\l@subsubsubsection{\@dottedtocline{4}{10.0em}{4.1em}}
\renewcommand*\l@paragraph{\@dottedtocline{5}{10em}{5em}}
\renewcommand*\l@subparagraph{\@dottedtocline{6}{12em}{6em}}
\newcommand*{\subsubsubsectionmark}[1]{}
\makeatother

\usepackage{hyperref}

\makeatletter
\def\toclevel@subsubsubsection{4}
\def\toclevel@paragraph{5}
\def\toclevel@subparagraph{6}
\makeatother


\definecolor{ligthgray}{RGB}{218, 218, 218}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\selectlanguage{english}
<<knitr_parameters, include = FALSE>>= 
library(knitr)
opts_chunk$set(fig.keep = 'high', dev = 'pdf', fig.width = 7, fig.height = 7, 
               fig.align = 'center', tidy = FALSE, warning = FALSE, size = "small", 
               fig.show = "hold", cache =  TRUE)
options(digit = 2)
a <- Sys.time()
@

<<crop-hook, include = FALSE>>=
knit_hooks$set(crop=hook_pdfcrop)
@

\maketitle

\begin{abstract}

\end{abstract}


\textbf{Key words:}
Functional space, functional structure, community assembly, ecological niche, environmental filter,
individual differences, intraspecific variation, null model, trait, variance decomposition


\vfill
\begin{center}
\textbf{To read a summary of this appendix, see directly section Summary \ref{sect:summary}.}
\textbf{An up to date version of the cati tutorial is available \href{https://github.com/adrientaudiere/cati/blob/Package-cati/tutorials/vignette_Darwin_finches/vignette.pdf}{here}.}
\end{center}

\newpage
\tableofcontents
\newpage


\section{Introduction}
 This document shows the lack of bias in the functions \texttt{Tstats}, \texttt{partvar}, \texttt{decompCTRE} and a test of robustness for the T-statistics.
This report was created on \Sexpr{a}. Start directly by the summary section if you want condensate results of this document.

\subsection{R requirements}

First we need to install and load the package. 
<<R_requirement, results = 'hide', message = FALSE>>= 
# install.packages("cati", repos = "http://cran.us.r-project.org", dependencies = TRUE)
library("cati")
library("xtable")

# Save the graphical parameter
oldpar <- par(no.readonly = TRUE)
@

  \subsection{System and session informations}
  This document was created with \Sexpr{sessionInfo()[[1]]$version.string} on \Sexpr{Sys.info()[1]}. See below for more information. The speed computations of \texttt{cati} main functions are develop  in the \href{https://github.com/adrientaudiere/cati/blob/Package-cati/tutorials/vignette_Darwin_finches/vignette.pdf}{cati tutorial}.
  
<<sessionInfo>>=
sessionInfo()
@

  \subsection {T-statistics and associated null models}
  
  
\begin{landscape}
\begin{table}[h]
\caption[T-statistics and associated null models]{The four types of null models implemented in cati, their related null and alternative hypotheses, randomization design and associated T-statistics}
\begin{tabular}{m{2.7cm} m{5.3cm} m{6.3cm} m{6.2cm} m{2.5cm}}

& Null hypothesis & Randomization procedure & Unilateral alternative hypothesis & T-statistics  \tabularnewline
\hline \hline \hline

local & There is no internal filtering: the distribution of trait values of all individuals within a given community does not depend on species identity & Randomization of individual trait values within the community& Internal filtering significantly impacts the distribution of trait values within a given community: two individuals belonging to a population have more similar trait values than two individuals randomly-drawn in the community & $T_{IP/IC}$   \tabularnewline

\hline

regional.ind  & There is no external filtering: the distribution of trait values of individuals within a given community is a random drawing from the regional pool & Draw without replacement of individual trait values belonging to the regional pool (keeping the actual number of individuals in each community) & Two individuals belonging to a community have more similar trait values than two individuals randomly-drawn in the regional pool & $T_{IC/IR}$\tabularnewline

\hline

regional.pop \& regional.pop.prab & There is no species-based external filtering: the distribution of mean trait values of species within a given community is a random draw from the regional pool & (i) Assignment of a population-level value to each individual and (ii) Draw without replacement of population-level trait values belonging to the regional pool (keeping the actual number of individuals in each community (regional.pop) or not (regional.pop .prab). & Two individuals belonging to a community have more similar population-based trait values than two individuals randomly-drawn in the regional pool with (regional.pop) or without (regional.pop .prab) taking abundance into account. & $T_{PC/PR}$  (regional.pop) \tabularnewline


\end{tabular}
\end{table}
\end{landscape}


  
  
  
  
  
  
  \subsection{Simulations parameters}

Here we define the number of permutations for the entire analysis. 

<<Simul_parameter_1>>= 
#Number of permutations for the analysis with no filter
npermut <- 3

#Number of permutations for each parameters values in the analysis with filter(s)
N_repet_Param <- 2

#Number of values for each parameters
nb_param_val <- 3
@

<<Simul_parameter_2>>= 
#Total number of individuals
Nind <- 1000

#Ten communities named A, B, C ... J
com <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J") 
Ncom <- length(com)

#Number of species (if Nsp > 676 you need to defined additional name)
Nsp <- 200
sp <- paste("sp", paste(sort(rep(LETTERS, 26)), rep(LETTERS, 26),  sep="")
                  [seq(1:Nsp)], sep ="_")
Nsp <- length(sp)

#Parameter of the log normal distribution for species abundances 
#distribution within communities
sdlog = 1.5
@

We use toys models of \Sexpr{Nind} individuals belonging to \Sexpr{Nsp} species occuring in \Sexpr{Ncom} communities (sites). Each community contains \Sexpr{Nind / Ncom} individuals and species abundances in each community are defined following a lognormal distribution of mean 0 and standard deviation \texttt{sdlog} of \Sexpr{sdlog}.
Figure \ref{fig:General_outline} depicts the general outline of the next fourth sections dealing with the statistical test of T-statistics from Violle \textit{et al.} (2012).

\begin{figure}[h]
\centering
\hspace*{-0.8cm}
\vspace*{-0.5cm}
    \makebox[\linewidth]{
        \includegraphics[width=0.9\linewidth]{general_outline.pdf}
    }
\caption[General outline of the simulation concerning the Tstatistics]{General outline of the simulation concerning the Tstatistics. (Continue on next page) }
\label{fig:General_outline}
\end{figure}

\clearpage
\textbf{Figure 1 (continue):} The \textbf{absence of filtering} is used to test the type I error (alpha-error) of the three Tstatistics. In the absence of filtering the expected pattern is a random distribution of individual traits values into species and communities. \textbf{Internal filter} includes all of the assembly processes internal to the community. The alternative hypothesis (thus the expected pattern) of habitat filtering is the non-overlap between species traits distributions measured by the ratio $T_{IP/IC}$. We modulate the strength of filter in the simulation using the variance of species traits distributions and the distance between species traits means. \textbf{External filter} includes all of the assembly processes external to the community. In this document we specifically treat the case of an environnemental gradient influencing the individual traits values. Thus the expected pattern a non-overlap between communities traits distributions measured by the ratio $T_{IC/IR}$ and its populationnal counterparts. We modulate the strength of external filter in the simulation using the variance of communities traits distributions and the range of communities traits means (the "extent" of the environnemental gradient). Finally, we add external filter to internal filter by adding to each individual values of the internal filter simulation a number depending on the community distribution.
\vspace*{1cm}




\cleardoublepage

\section{No filter: calculation of error}
 \subsection {Randomization outline}

To calculate the \textbf{alpha error} (\textit{i.e.} the probability of rejected the null hypothesis H0 while H0 is true), we draw \Sexpr{npermut} random traits matrix irrespective of the species and community attributes of each individuals.

<<No_filter, results = 'hide'>>= 
#Start simulation 
res.simu1 <- list() ; res.simu1.pval <- list()

for(n in 1:npermut){#for each permutation

 ex.traits1 <- array(NA, dim = c(Nind, 2))
 colnames(ex.traits1) <- paste("trait", c("a", "b"), sep = " ")

 #trait a: normal distribution
 ex.traits1[, 1] <- rnorm(Nind, rlnorm(Nind, 0, 1), rlnorm(Nind, 0, 1))

 #trait b: uniform distribution
 ex.traits1[, 2] <- runif(Nind)

 # Draw communities using lognormal distribution of abundances 
 ex.sp1 <- c()
 ex.com1 <- matrix(0, nrow = Ncom, ncol = Nsp)
 for(c in 1: Ncom){
  ex.com.interm <- table(sample(sp, size = Nind / Ncom, prob = rlnorm(Nsp, 0, sdlog), 
                                replace = T))
 
  ex.com1[c, sp %in% names(ex.com.interm)] <- ex.com.interm
 
  ex.sp1 <- c(ex.sp1, rep(sp, times = ex.com1[c,]))
 }
 ex.indplot1 <- sort(as.factor(rep(com, 100)))

 #Stock the results
 res.simu1[[n]] <- Tstats(ex.traits1, ex.indplot1, ex.sp1)
 res.simu1.pval[[n]] <- sum_Tstats(res.simu1[[n]], type = "p.value")
 print(paste("---", round(n/npermut, 2) * 100, "%", sep = " "))
}#End of simulations
@

  \subsection {Results for simulations with no filtering}
Let's see the result for one typical randomization. We can plot the distribution of traits within species and/or communities thanks to the function \texttt{plotDistri} (Fig. \ref{fig:No_Filter_plots}). We can also plot the result of the T-statistics for one of the \Sexpr{npermut} permutations (Fig. \ref{fig:No_Filter_plots_Tstats}).

<<No_Filter_plots, fig.cap = "Distribution of traits for one randomization without filter: (a) Communities trait distributions for the trait a (normal distribution); (b) Communities trait distributions for the trait b (uniform distribution); (c) Species trait distributions for the trait a; (d) Species trait distributions for the trait b", crop = TRUE>>= 
par(mfrow=c(2, 2))
plotDistri(ex.traits1, rep("all_sp", times = dim(ex.traits1)[1]), ex.indplot1, 
           plot.ask = F, multipanel = F, leg =c(T, F), main = c("a", "b"))
plotDistri(ex.traits1, rep("region", times = dim(ex.traits1)[1]), ex.sp1, 
           plot.ask = F, multipanel = F, leg =c(T, F), main = c("c", "d"))
par(mfrow=c(1, 1))
@

<<No_Filter_plots_Tstats, fig.height = 4, fig.cap = "Results of T-statistics for one randomization without filter: $T_{IP/IC}$ in red, $T_{IC/IR}$ in purple and $T_{PC/PR}$ in green.", crop = TRUE>>= 
plot(res.simu1[[1]])
@

 \subsection {Assess the statistical type I error of local T-statistics}
 
Here we call local p-values the p-values corresponding to one indice for one trait in one community \footnote{In contrast with global statistics which aggregate the communities values metrics.}. Now lets plot the results as the ordered p.value for each T-statistics and each traits (Fig. \ref{fig:No_Filter_results})). In that case we have \Sexpr{Ncom*2} p-values \footnote{\Sexpr{Ncom} p-value, corresponding to \Sexpr{Ncom} communities, multiply by 2 because we are doing a bilateral test} by T-statistics by traits for each permutation. Using the defined parameters, we plot \Sexpr{Ncom*2*npermut} points by T-statistic by trait (\Sexpr{Ncom*2} p.value multiply by \Sexpr{npermut} permutation). 

The alpha error on the figure are the proportion of p.value which are inferior to 0.025 (because we are doing a bilateral test).

<<No_Filter_results, fig.cap = "Local alpha errors: local p.values are log-transformed and ordered before plotting. The black line represent the value of 0.025. Consequently, p-values under this line are false-positive cases. Alpha-error is the proportion of this false-positive cases. Norm: normal distribution, Uni: uniforme distribution.", crop = TRUE>>= 
par(mfrow = c(3, 2))
par(mar = c(3, 3.5, 2, 0.2))

xx <- log10(sort(unlist(lapply(res.simu1.pval, function(x) x[1:20, 1]))))
plot(xx, type = "l", main = "T_IP.IC norm", ylab = NA , xlab = NA)
abline(h = log10(0.025)) 
nbre_alpha_error_norm_loc_Tipic <- round((sum(xx < log10(0.025)) +1 ) / (length(xx)+1), 5)
text(0, -0.3, labels = paste("alpha error", nbre_alpha_error_norm_loc_Tipic, sep = " = "), 
     pos = 4)
mtext("log10 pvalue", 2, line = 2)

xx <- log10(sort(unlist(lapply(res.simu1.pval, function(x) x[1:20, 2]))))
plot(xx, type = "l", main = "T_IP.IC Uni", ylab = NA, xlab = NA)
abline(h = log10(0.025))
nbre_alpha_error_uni_loc_Tipic <- round((sum(xx < log10(0.025)) +1 ) / (length(xx)+1), 5)
text(0, -0.3, labels = paste("alpha error", nbre_alpha_error_uni_loc_Tipic, sep = " = "), 
     pos = 4)

xx <- log10(sort(unlist(lapply(res.simu1.pval, function(x) x[21:40, 1]))))
plot(xx, type = "l", main = "T_IC.IR norm", ylab = NA, xlab = NA)
abline(h = log10(0.025)) 
nbre_alpha_error_norm_loc_Ticir <- round((sum(xx < log10(0.025)) +1 ) / (length(xx)+1), 5)
text(0, -0.3, labels = paste("alpha error", nbre_alpha_error_norm_loc_Ticir, sep = " = "),
     pos = 4)
mtext("log10 pvalue", 2, line = 2)

xx <- log10(sort(unlist(lapply(res.simu1.pval, function(x) x[21:40, 2]))))
plot(xx, type = "l", main = "T_IC.IR Uni", ylab = NA, xlab = NA)
abline(h = log10(0.025)) 
nbre_alpha_error_uni_loc_Ticir <- round((sum(xx < log10(0.025)) +1 ) / (length(xx)+1), 5)
text(0, -0.3, labels = paste("alpha error", nbre_alpha_error_uni_loc_Ticir, sep = " = "),
     pos = 4)

xx <- log10(sort(unlist(lapply(res.simu1.pval, function(x) x[41:60, 1]))))
plot(xx, type = "l", main = "T_PC.PR norm", ylab = NA, xlab = NA)
abline(h = log10(0.025)) 
nbre_alpha_error_norm_loc_Tpcpr <- round((sum(xx < log10(0.025)) +1 ) / (length(xx)+1), 5)
text(0, -0.3, labels = paste("alpha error", nbre_alpha_error_norm_loc_Tpcpr, sep = " = "),
     pos = 4)
mtext("log10 pvalue", 2, line = 2)
mtext("rank", 1, line = 2)

xx <- log10(sort(unlist(lapply(res.simu1.pval, function(x) x[41:60, 2]))))
plot(xx, type = "l", main = "T_PC.PR Uni", ylab = NA, xlab = NA)
abline(h = log10(0.025)) 
nbre_alpha_error_uni_loc_Tpcpr <- round((sum(xx < log10(0.025)) +1 ) / (length(xx)+1), 5)
text(0, -0.3, labels = paste("alpha error", nbre_alpha_error_uni_loc_Tpcpr, sep = " = "),
     pos = 4)
mtext("rank", 1, line = 2)

par(oldpar)
@

 \subsection {Assess the statistical type I error of global T-statistics}

In contrast with local p-values, we call global p-values the p-values corresponding to one indice for one trait across all the communities. 

We test for the \textbf{alpha error} of global p-values in the same way as local p-values. We plot the ordered mean \footnote{mean of the ten communities values} standardized effect size (SES)\foonote{compute as $(the observed value - the mean value among simulation) / the standard error among simulations$} and the 95\% confidence interval in grey. 

In that case we have one p-value by T-statistics by traits for each of the \Sexpr{npermut} permutations.

<<No_filter_summary>>= 
meanSES.1.T_IP.IC.distriNorm <- lapply(res.simu1, function(x) 
          mean(ses.listofindex(as.listofindex(x))
           $index_1_1$ses[,1], na.rm = T))

meanSES.1.T_IC.IR.distriNorm <- lapply(res.simu1, function(x) 
          mean(ses.listofindex(as.listofindex(x))
           $index_1_2$ses[,1], na.rm = T))

meanSES.1.T_PC.PR.distriNorm <- lapply(res.simu1, function(x) 
          mean(ses.listofindex(as.listofindex(x))
           $index_1_3$ses[,1], na.rm = T))

meanSES.1.T_IP.IC.distriUni <- lapply(res.simu1, function(x) 
          mean(ses.listofindex(as.listofindex(x))
           $index_1_1$ses[,2], na.rm = T))

meanSES.1.T_IC.IR.distriUni <- lapply(res.simu1, function(x) 
          mean(ses.listofindex(as.listofindex(x))$
            index_1_2$ses[,2], na.rm = T))

meanSES.1.T_PC.PR.distriUni <- lapply(res.simu1, function(x) 
          mean(ses.listofindex(as.listofindex(x))
           $index_1_3$ses[,2], na.rm = T))
@

Now, plot the result as ordered SES values (Fig. \ref{fig:No_filter_summary_plot}). Horizontal lines represent the confidence area at 95\%.
 
<<No_filter_summary_plot, fig.cap = "Global alpha errors: global Standardized Effect Size are ordered before plotting. The grey area represent the confidence interval at 2.5 percent on each side. Consequently, p-values outside this area are false-positive cases. Alpha-error is the proportion of this false-positive cases. Norm: normal distribution, Uni: uniforme distribution.", crop = TRUE>>= 
par(mfrow = c(3, 2))
par(mar = c(3, 3.5, 2, 0.2))

####   T_IP.IC
#T_IP.IC.distriNorm
xx <- sort(unlist(meanSES.1.T_IP.IC.distriNorm))
xx_lim.inf <- unlist(lapply(res.simu1, function(x) mean(ses.listofindex(as.listofindex(x))
              $index_1_1$ses.inf[,1], na.rm = T)))
xx_lim.sup <- unlist(lapply(res.simu1, function(x) mean(ses.listofindex(as.listofindex(x))
              $index_1_1$ses.sup[,1], na.rm = T)))
alpha1 <- round((sum(xx<xx_lim.inf | xx>xx_lim.sup)+1) / (length(xx)+1), 3)

plot(xx, type = "l", main = "T_IP.IC norm", ylim = c(-3, 3),
     ylab = NA, xlab = NA)
rect(-100, mean(xx_lim.inf), npermut*1.2, mean(xx_lim.sup), col = rgb(0, 0, 0, 0.2))
text(3, 0.8, labels = paste("alpha error", alpha1, sep = " = "), cex = 0.7, pos = 4)
mtext("Standardized Effect Size", 2, line = 2)

#T_IP.IC.distriUni
xx <- sort(unlist(meanSES.1.T_IP.IC.distriUni))
xx_lim.inf <- unlist(lapply(res.simu1, function(x) mean(ses.listofindex(as.listofindex(x))
              $index_1_1$ses.inf[,2], na.rm = T)))
xx_lim.sup <- unlist(lapply(res.simu1, function(x) mean(ses.listofindex(as.listofindex(x))
              $index_1_1$ses.sup[,2], na.rm = T)))
alpha2 <- round((sum(xx<xx_lim.inf | xx>xx_lim.sup)+1) / (length(xx)+1), 3)

plot(xx, type = "l", main = "T_IP.IC uni", ylim = c(-3, 3),
     ylab = NA, xlab = NA)
rect(-100, mean(xx_lim.inf), npermut*1.2, mean(xx_lim.sup), col = rgb(0, 0, 0, 0.2))
text(3, 0.8, labels = paste("alpha error", alpha2, sep = " = "), cex = 0.7, pos = 4)

#__________
####   T_IC.IR
#T_IC.IR.distriNorm
xx <- sort(unlist(meanSES.1.T_IC.IR.distriNorm))

xx_lim.inf <- unlist(lapply(res.simu1, function(x) mean(ses.listofindex(as.listofindex(x))
              $index_1_2$ses.inf[,1], na.rm = T)))
xx_lim.sup <- unlist(lapply(res.simu1, function(x) mean(ses.listofindex(as.listofindex(x))
              $index_1_2$ses.sup[,1], na.rm = T)))
alpha3 <- round((sum(xx<xx_lim.inf | xx>xx_lim.sup)+1) / (length(xx)+1), 3)

plot(xx, type = "l", main = "T_IC.IR norm", ylim = c(-3, 3),
     ylab = NA, xlab = NA)
rect(-100, mean(xx_lim.inf), npermut*1.2, mean(xx_lim.sup), col = rgb(0, 0, 0, 0.2))
text(3, 0.8, labels = paste("alpha error", alpha3, sep = " = "), cex = 0.7, pos = 4)
mtext("Standardized Effect Size", 2, line = 2)

#T_IC.IR.distriUni
xx <- sort(unlist(meanSES.1.T_IC.IR.distriUni))

xx_lim.inf <- unlist(lapply(res.simu1, function(x) mean(ses.listofindex(as.listofindex(x))
              $index_1_2$ses.inf[,2], na.rm = T)))
xx_lim.sup <- unlist(lapply(res.simu1, function(x) mean(ses.listofindex(as.listofindex(x))
              $index_1_2$ses.sup[,2], na.rm = T)))
alpha4 <- round((sum(xx<xx_lim.inf | xx>xx_lim.sup)+1) / (length(xx)+1), 3)

plot(xx, type = "l", main = "T_IC.IR uni", ylim = c(-3, 3),
     ylab = NA, xlab = NA)
rect(-100, mean(xx_lim.inf), npermut*1.2, mean(xx_lim.sup), col = rgb(0, 0, 0, 0.2))
text(3, 0.8, labels = paste("alpha error", alpha4, sep = " = "), cex = 0.7, pos = 4)

#__________
####   T_PC.PR
#T_PC.PR.distriNorm
xx <- sort(unlist(meanSES.1.T_PC.PR.distriNorm))

xx_lim.inf <- unlist(lapply(res.simu1, function(x) mean(ses.listofindex(as.listofindex(x))
              $index_1_3$ses.inf[,1], na.rm = T)))
xx_lim.sup <- unlist(lapply(res.simu1, function(x) mean(ses.listofindex(as.listofindex(x))
              $index_1_3$ses.sup[,1], na.rm = T)))
alpha5 <- round((sum(xx<xx_lim.inf | xx>xx_lim.sup)+1) / (length(xx)+1), 3)

plot(xx, type = "l", main = "T_PC.PR norm", ylim = c(-3, 3),
     ylab = NA, xlab = NA)
rect(-100, mean(xx_lim.inf), npermut*1.2, mean(xx_lim.sup), col = rgb(0, 0, 0, 0.2))
text(3, 0.8, labels = paste("alpha error", alpha5, sep = " = "), cex = 0.7, pos = 4)
mtext("Standardized Effect Size", 2, line = 2)
mtext("rank", 1, line = 2)

#T_PC.PR.distriUni
xx <- sort(unlist(meanSES.1.T_PC.PR.distriUni))
xx_lim.inf <- unlist(lapply(res.simu1, function(x) mean(ses.listofindex(as.listofindex(x))
              $index_1_3$ses.inf[,2], na.rm = T)))
xx_lim.sup <- unlist(lapply(res.simu1, function(x) mean(ses.listofindex(as.listofindex(x))
              $index_1_3$ses.sup[,2], na.rm = T)))
alpha6 <- round((sum(xx<xx_lim.inf | xx>xx_lim.sup)+1) / (length(xx)+1), 3)

plot(xx, type = "l", main = "T_PC.PR uni", ylim = c(-3, 3),
     ylab = NA, xlab = NA)
rect(-100, mean(xx_lim.inf), npermut*1.2, mean(xx_lim.sup), col = rgb(0, 0, 0, 0.2))
text(3, 0.8, labels = paste("alpha error", alpha6, sep = " = "), cex = 0.7, pos = 4)
mtext("rank", 1, line = 2)

par(oldpar)
@

  \subsection {Conclusion on the type I error of T-statistics}

The \Sexpr{npermut} permutations allow the calculation of alpha error for two traits (the first normally distributed and the second uniformally distributed), three indices (the three T-statistics) and using local indices (one by community) or global indices (averaged between communities).

\begin{table}[h!]
\begin{center}
\caption{Alpha-errors for T-statistics}
\label{tab:Alpha-errors_for_T-stats}
\begin{tabular}{|c|c|c|c|c|}
\hline
Traits & Indices & Average between communities? & alpha-error \tabularnewline
\hline \hline \hline
\multirow{6}{*}{Trait normally distributed} & \multirow{2}{*}{$T_{IP/IC}$} & no (local) & \Sexpr{round(nbre_alpha_error_norm_loc_Tipic, 3)} \tabularnewline
\cline{3-4} 
 & & yes (global) & \Sexpr{round(alpha1, 3)} \tabularnewline
\cline{2-4} 
 & \multirow{2}{*}{$T_{IC/IR}$} & no (local) & \Sexpr{round(nbre_alpha_error_norm_loc_Ticir, 3)} \tabularnewline
\cline{3-4} 
 & & yes (global) & \Sexpr{round(alpha3, 3)} \tabularnewline
\cline{2-4} 
 & \multirow{2}{*}{$T_{PC/PR}$} & no (local) & \Sexpr{round(nbre_alpha_error_norm_loc_Tpcpr, 3)} \tabularnewline
\cline{3-4}
 & & yes (global)& \Sexpr{round(alpha5, 3)} \tabularnewline

\hline \hline \hline

\multirow{6}{*}{Trait uniformally distributed} & \multirow{2}{*}{$T_{IP/IC}$} & no (local) & \Sexpr{round(nbre_alpha_error_uni_loc_Tipic, 3)} \tabularnewline
\cline{3-4}
 & & yes (global) &  \Sexpr{round(alpha2, 3)} \tabularnewline
\cline{2-4} 
 & \multirow{2}{*}{$T_{IC/IR}$} & no (local) & \Sexpr{round(nbre_alpha_error_uni_loc_Ticir, 3)} \tabularnewline
\cline{3-4} 
 & & yes (global) &  \Sexpr{round(alpha4, 3)} \tabularnewline
\cline{2-4} 
 & \multirow{2}{*}{$T_{PC/PR}$} & no (local) & \Sexpr{round(nbre_alpha_error_uni_loc_Tpcpr, 3)} \tabularnewline
\cline{3-4} 
 & & yes (global)&  \Sexpr{round(alpha6, 3)} \tabularnewline
\hline 
\end{tabular}
\end{center}
\end{table}



The results of table \ref{tab:Alpha-errors_for_T-stats} attest of a good behavior of the T-statistics regardless of the distributions of the traits. Alpha-error of the local indices are always near the wanted alpha-error of 2.5\%. Logically the global indices which averaged local indices are far more robust. Note that the higher alpha-error is obtained using $T_{PC/PR}$ on the trait normally distributed (\Sexpr{round(nbre_alpha_error_norm_loc_Tpcpr, 3)}).















































\cleardoublepage

\section{Internal filter: assess the statistical power of $T_{IP/IC}$}
  \subsection {Randomization outline}
 
We decide to modulate the strength of the internal filter thanks to two parameters:
we define (i) a gradient of distance between species means traits distributions and (ii) a gradient of the mean variance in species traits distributions. It is strongly linked to the definition of limiting similarity by May and Mac Arthur (1972) who defined a coefficient of competition as $$a = exp (-d^2/4w^2)$$ with \texttt{d} correspond to the distance between the species trait means and \texttt{w} correspond to the mean variance of species trait distribution. 

<<Internal_filter>>= 
# Number of values for each parameters: param_DIST_between_MEAN.init and param_SD
nb_param_val

# Number of permutations is the product of the number of values for each parameter
#(nb_param_val) and the number of permutations by parameter (N_repet_Param)
nperm <- nb_param_val * N_repet_Param

# Maximum mean value for traits
max.value_traits <- 250

# Parameter for the distance between species mean trait values
param_DIST_between_MEAN.init <- round(sort(seq(10, 200, length.out = nb_param_val)), 2)
param_DIST_between_MEAN <- rep(param_DIST_between_MEAN.init, N_repet_Param)
mean_sd.param <- rep(10, nperm)

# Parameter for the variance in species mean trait values
param_SD <- seq(10, 100,length.out = nb_param_val)
sd_mean.param <- sample (rep(param_SD, N_repet_Param), 
       size = length(rep(param_SD, N_repet_Param)), replace = F)
sd_sd.param <- rep(10, nperm)
@


 Practically, we defined \Sexpr{nb_param_val} values for two parameters:
\\

 (i) \texttt{param\_{}DIST\_{}between\_{}MEAN.init} is a vector of length \Sexpr{nb_param_val} which defined the minimum values for the mean traits values (the maximum values are defined to \Sexpr{250}). In decreasing the range of traits values while keeping the same number of species, there is a decrease of mean distance between species means of traits values. Thus the mean for each species is drawn from a normal distribution with standard deviation of \Sexpr{mean_sd.param[1]} (parameter \texttt{mean\_{}sd.param}) and means evenly distributed between \texttt{max.value\_{}traits - param\_{}DIST\_{}between\_{}MEAN} and \texttt{max.value\_{}traits}.
\\

(ii) \texttt{param\_{}SD} is a vector of length \Sexpr{nb_param_val} which defined the standard deviation of traits distributions for each species. In order to decorrelate the mean and standard deviation of species traits distributions, \texttt{param\_{}SD} is permuted before the analysis. 
\\

For the trait "a" the trait value for each individual is drawn from a normal distribution with the mean depending on it species attribute. For the trait "b" the trait value for each individual is drawn from a uniform distribution with the range depending on it species attribute. The range is defined as: \textit{species mean value} - \textit{species sd value} for the minimum and \textit{species mean value} + \textit{species sd value} for the maximum.

Now we can start the simulation with \Sexpr{nb_param_val} parameters values and \Sexpr{N_repet_Param*length(param_SD)} permutations. 

<<Internal_filter_simu, results = 'hide'>>= 
mean.sp_stock2 <- list() ; sd.sp_stock2 <- list() ; res.simu2 <- list()
res.simu2.pval <- list() ; res.simu.traits2 <- list() ;  mean_dist_sp <- list()

for(n in 1:nperm){#for each permutation
 
 # Draw communities using lognormal distribution of abundances 
 # 100 individuals by populations
 ex.sp2 <- c()
 ex.com2 <- matrix(0, nrow = Ncom, ncol = Nsp)
 for(i in 1: Ncom){
  ex.com.interm <- table(sample(sp, size = Nind/Ncom, prob = rlnorm(Nsp, 0, sdlog), 
                                replace = T))
  ex.com2[i, sp%in% names(ex.com.interm)] <- ex.com.interm
  ex.sp2 <- c(ex.sp2, rep(sp, times = ex.com2[i,]))
 }

 ex.indplot2 <- sort(as.factor(rep(com, Nind/Ncom)))

 # Defining traits mean and sd by species 
 mean_mean.param.interm <- seq(max.value_traits - param_DIST_between_MEAN[n], 
                               max.value_traits, length.out = 
                               length(unique(param_DIST_between_MEAN)))

 mean_mean.param <- rep(round(sort(mean_mean.param.interm), 2), N_repet_Param)

 mean.sp <- rnorm(length(unique(sp)), mean = mean_mean.param, sd = mean_sd.param[n])
 sd.sp <- rnorm(length(unique(sp)), mean = sd_mean.param[n], sd = sd_sd.param[n]) 

 ex.traits2 <- array(NA, dim = c(Nind, 2))
 colnames(ex.traits2) <- paste("trait", c("a", "b"), sep = " ")

 # Draw the individual traits depending on species attributes
  for(s in unique(ex.sp2)){
   #trait a : normal distribution
   ex.traits2[ex.sp2 == s, 1] <- 
   rnorm(5*Nind/Ncom, rep(mean.sp[unique(ex.sp2) == s], 5*Nind/Ncom),
         rep(sd.sp[unique(ex.sp2) == s], 5*Nind/Ncom))[1:sum(ex.sp2 == s)]
 
   #trait b : uniform distribution
   ex.traits2[ex.sp2 == s, 2] <- 
   runif(5*Nind/Ncom, min = rep(mean.sp[unique(ex.sp2) == s], 5*Nind/Ncom) - 
         rep(sd.sp[unique(ex.sp2) == s], 5*Nind/Ncom), 
         max = rep(mean.sp[unique(ex.sp2) == s], 5*Nind/Ncom) + 
         rep(sd.sp[unique(ex.sp2) == s], 5*Nind/Ncom))[1:sum(ex.sp2 == s)]
  }

 #stock results
 mean.sp_stock2[[n]] <- mean.sp 
 sd.sp_stock2[[n]] <- sd.sp

 mean_dist_sp[[n]] <- c(mean(tapply(ex.traits2[, 1], ex.indplot2, function(x)
                                    mean(dist(x), na.rm=T)), na.rm=T),
                        mean(tapply(ex.traits2[, 2], ex.indplot2, function(x)
                                    mean(dist(x), na.rm=T)), na.rm=T))
  
 res.simu.traits2[[n]] <- ex.traits2
 res.simu2[[n]] <- Tstats(ex.traits2, ex.indplot2, ex.sp2, printprogress = FALSE)
 res.simu2.pval[[n]] <- sum_Tstats(res.simu2[[n]], type = "p.value")
 print(paste(round(n/nperm, 2) * Nind/Ncom, "%", sep = " "))
}#End of simulations
@


 \subsection {Results for simulations of internal filtering}

Let's see the result for one typical randomization. We can plot the distribution of traits within species and/or communities thanks to the function \texttt{plotDistri} (Fig. \ref{fig:typical_result_internal_filtering1}). 

<<typical_result_internal_filtering1, fig.cap = "Distribution of traits for one randomization with internal filtering: (a) Communities trait distributions for the trait a (normal distribution); (b) Communities trait distributions for the trait b (uniform distribution); (c) Species trait distributions for the trait a; (d) Species trait distributions for the trait b", crop = TRUE>>= 
par(mfrow=c(2, 2))
plotDistri(ex.traits2, rep("all_sp", times = dim(ex.traits2)[1]), ex.indplot2, 
           plot.ask = F, multipanel = F, cex.leg = 0.6, main= c("a", "b"))
plotDistri(ex.traits2, rep("region", times = dim(ex.traits2)[1]), ex.sp2, plot.ask = F, 
           multipanel = F, ylim = c(0,0.04), cex.leg = 0.6, main= c("c", "d"))
par(mfrow=c(1, 1))
@

We can also plot the result of the T-statistics for two contrasting cases (Fig. \ref{fig:typical_result_internal_filtering2}).

<<typical_result_internal_filtering2, fig.height = 8, fig.cap = "Results of T-statistics for two randomization with contrasted strength of internal filtering: $T_{IP/IC}$ in red, $T_{IC/IR}$ in purple and $T_{PC/PR}$ in green. (a) Lower strength of internal filtering and (b) higher strength of internal filtering.", crop = TRUE>>= 
par(mfrow=c(2, 1))
plot(res.simu2[[1]], main="a")
plot(res.simu2[[n]], main="b")
par(mfrow=c(1, 1))
@

For the power analysis of internal filtering we present the result in two parts: (i) the test of robustness of each T-statistics values using local p-values and (ii) the test of community-aggregated T-statistics using global p-values.

 \subsubsection {Local p-values results}

Here we call local p-values the p-values corresponding to one indice for one trait in one community. First, we can represent the ordered p.value in decimal logarithms and calculate the power of the $T_{IP/IC}$ indice using the beta-error\footnote{The proportion of case where we do not reject the null hypothesis while this hypothesis is wrong.}. The less the beta-error, the more the indice is powerful. Contrary to the test with no filter, we choose a unilateral test because we only want to test if $T_{IP/IC}$ is smaller than it should be under the associated null hypothesis.

We can plot the local p-values in different ways. First, we can represent the ordered p.value in decimal logarithms and calculate the power of the $T_{IP/IC}$ indice using the beta-error. The less the beta-error, the more the indice is powerful. Contrary to the test with no filter, we choose a unilateral test because we only want to test if $T_{IP/IC}$ is smaller than it should be under the associated null hypothesis.

  \subsubsubsection {Calculation of beta-error mixing all strength of filtering}
 
<<Internal_filter_results_pval_local, fig.height = 3, crop = TRUE, fig.cap = "Beta-error mixing all strength of internal filtering: Standardized effect size of $T_{IP/IC}$ are ordered and plot. The black line represent the value of 0.05. Consequently, p-values above this line are false-negative cases. Norm: normal distribution, Uni: uniforme distribution. " >>= 
par(mfrow = c(1, 2))
xx <- log10(sort(unlist(lapply(res.simu2.pval, function(x) x[1:10, 1]))))
plot(xx, type = "l", main = "T_IP.IC Norm", 
     xlab = "rank", ylab = "Standardized Effect Size")
abline(h = log10(0.05))
nbre_beta_error <- round((sum(xx>log10(0.05))+1)/(length(xx)+1), 4)
text(0, -0.8, labels = paste("beta error", nbre_beta_error, sep = " = "), 
  cex = 0.7, pos = 4)

xx <- log10(sort(unlist(lapply(res.simu2.pval, function(x) x[1:10, 2]))))
plot(xx, type = "l", main = "T_IP.IC Uni", 
     xlab = "rank", ylab = "Standardized Effect Size")
abline(h = log10(0.05))
nbre_beta_error <- round((sum(xx>log10(0.05))+1)/(length(xx)+1), 4)
text(0, -0.8, labels = paste("beta error", nbre_beta_error, sep = " = "), 
  cex = 0.7, pos = 4)
par(oldpar)
@

The beta-error is very high and thus the power of $T_{IP/IC}$ can \textit{prima facie} seen as problematic (Fig. \ref{fig:Internal_filter_results_pval_local}). But here we mingle the p-value for several parameters values. Thus it is far more informative to see the power of the test in relation to the initial parameters values. We represent standardized effect sizes values (hereafter called SES) in relation to the strength of internal filter to determine the parameters values which allow a satisfactory power of $T_{IP/IC}$.

As we add stochasticity around the initial parameters values, we can measure the strength of internal filtering by (i) the initial parameter values or (ii) by calculating the modeled parameter values\footnote{\textit{i.e.} the parameter values after adding stochasticity}.
 
  \subsubsubsection {Local $T_{IP/IC}$ SES values against initial parameter values}

<<Internal_filter_results_SES>>= 
meanSES.2loc.norm_Tipic <- unlist(lapply(res.simu2, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_1$ses[, 1]))

meanSES.2loc.uni_Tipic <- unlist(lapply(res.simu2, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_1$ses[, 2]))

SES.inf.MEAN.norm_Tipic <- unlist(lapply(res.simu2, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_1$ses.inf[, 1]))

SES.inf.MEAN.uni_Tipic <- unlist(lapply(res.simu2, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_1$ses.inf[, 2]))
@

Now, we can plot SES of $T_{IP/IC}$ (Fig. \ref{fig:In_filter_results_plot_initparam}). The trait "a" normally distributed is in black and the uniform traits "b" is in purple. The colored rectangles represent the null model area with alpha = 5\%. Thus, when a point is outside these area, the modeled parameters are strong enough to detect the internal filter with a high power (beta-error $ < 0.05$).

  
<<In_filter_results_plot_initparam, fig.height = 4, fig.cap = "Local $T_{IP/IC}$ SES and initial parameters values: Standardized effect size of $T_{IP/IC}$ in function of the strength of internal filter defined by the ratio of the initial range parameter by the initial standard error parameter. Colored area represent the mean confidence interval of SES values ($alpha = 0.95$). Trait a (normal) in black and b (uniform) in purple.", dev ='png', dpi = 100, fig.scap = "Local $T_{IP/IC}$ SES and initial parameters values">>= 
init_param <- param_DIST_between_MEAN / sd_mean.param
init_param.loc <- rep(init_param, each = Ncom)

plot(meanSES.2loc.norm_Tipic, init_param.loc, pch = 16, col = rgb(0, 0, 0, 0.6),
     xlim = c(min(c(unlist(meanSES.2loc.norm_Tipic), unlist(meanSES.2loc.uni_Tipic)), 
     na.rm = T), 0),
     main = "Local T_IP.IC",
     xlab = "standardized effect size of T_IP.IC",
     ylab = "initial parameters: range/sd")
abline(v = mean(SES.inf.MEAN.norm_Tipic, na.rm = T))

points(meanSES.2loc.uni_Tipic, init_param.loc, pch = 16, col = rgb(0.5, 0, 1, 0.6))
abline(v = mean(SES.inf.MEAN.uni_Tipic, na.rm = T), col = "purple")
rect(mean(SES.inf.MEAN.norm_Tipic, na.rm = T), -1, 0, max(init_param) + 1, 
     col = rgb(0, 0, 0, 0.3), border = NA)
rect(mean(SES.inf.MEAN.uni_Tipic, na.rm = T), 0, 0, max(init_param), 
     col = rgb(0.5, 0, 1, 0.3), border = NA)
@
 
  
For each initial parameters values we can calculate the proportion of case where we do not reject the null hypothesis while this hypothesis is wrong (\textit{i.e.} the Beta-error). The next chunk only shows the calculation for the $T_{IC/IR}$ metrics on the trait "a".

<<In_calculate_local_betaerrors>>= 
beta_sd_norm_Tipic <- 
 (unlist(lapply(by(cbind(meanSES.2loc.norm_Tipic, SES.inf.MEAN.norm_Tipic), 
     rep(sd_mean.param, each = Ncom), function(x) x[,1] > x[,2]),
     function(x) sum(x, na.rm = T)))+1)/(10 * N_repet_Param + 1)
beta_range_norm_Tipic <- 
 (unlist(lapply(by(cbind(meanSES.2loc.norm_Tipic, SES.inf.MEAN.norm_Tipic), 
     rep(param_DIST_between_MEAN, each = Ncom), function(x) x[,1] > x[,2]), 
     function(x) sum(x, na.rm = T)))+1)/(10 * N_repet_Param + 1)
   
beta_sd_uni_Tipic <- 
 (unlist(lapply(by(cbind(meanSES.2loc.uni_Tipic, SES.inf.MEAN.uni_Tipic), 
     rep(sd_mean.param, each = Ncom), function(x) x[,1] > x[,2]), 
     function(x) sum(x, na.rm = T)))+1)/(10 * N_repet_Param + 1)
beta_range_uni_Tipic <- 
 (unlist(lapply(by(cbind(meanSES.2loc.uni_Tipic, SES.inf.MEAN.uni_Tipic), 
     rep(param_DIST_between_MEAN, each = Ncom), function(x) x[,1] > x[,2]), 
     function(x) sum(x, na.rm = T)))+1)/(10 * N_repet_Param + 1)

res_beta_Tipic <- rbind(rev(beta_sd_norm_Tipic), rev(beta_sd_uni_Tipic), 
      beta_range_norm_Tipic, beta_range_uni_Tipic)
colnames(res_beta_Tipic) <- paste("str", 1:ncol(res_beta_Tipic))
rownames(res_beta_Tipic) <- c("effect of sd (a)", "effect of sd (b)", 
        "effect of range (a)", "effect of range (b)")
@

<<In_resultsof_local_betaerrors, results='asis'>>= 
print(xtable(res_beta_Tipic, caption = 'Local beta-error of $T_{IP/IC}$ in function 
             of the strength of internal filtering. str: strength. Trait a is 
             normally distributed and trait b is uniformally distributed.', 
             label = "tab:local_beta_error_xtable"), 
      caption.placement = "top", size = "small")
@
 

Now we can see the beta-error for each strength in table \ref{tab:local_beta_error_xtable}. A high value of range and a low value of standard error defined a high strength of filtering. For example, in the case of a trait normally distributed, the proportion of false negative is \Sexpr{round(res_beta_Tipic[1, 1]*100, 2)}\% for the higher value of standard errors and thus for the lower strength of internal filtering. The good behavior of the function \texttt{Tstats} is ascertained by the decrease of beta-error along increasing strength of filter.
 
 
  \subsubsubsection {Local $T_{IP/IC}$ SES values against modeled parameter values}
  
  First we need to calculate the modeled parameter values. Here again we calculate the strength of internal filtering by dividing the range of values in communities by their standard error.
  
<<In_filter_modeledparam>>= 
mean_dist_sp.interm <- t(matrix(unlist(lapply(mean_dist_sp, function(x) x)), nrow = 2))
mean_sd_of_com <- unlist(lapply(sd.sp_stock2, function(x) mean(x)))

modeled_param_norm <- mean_dist_sp.interm[, 1] / mean_sd_of_com 
modeled_param_uni <- mean_dist_sp.interm[, 2] / mean_sd_of_com 
modeled_param_norm.loc <- rep(modeled_param_norm, each = Ncom)
modeled_param_uni.loc <- rep(modeled_param_uni, each = Ncom)
@

<<In_filter_results_plot_modeledparam, fig.height = 4, fig.cap = "Local $T_{IP/IC}$ SES and modeled parameters values: Standardized effect size of $T_{IP/IC}$ in function of the strength of internal filter defined by the ratio of the modeled range parameter by the modeled standard error parameter. The colored rectangles represent the mean confidence interval for SES values ($alpha = 0.95$). Trait a (normal) in black and b (uniform) in purple.", dev ='png', dpi = 100, fig.scap = "Local $T_{IP/IC}$ SES and modeled parameters values">>= 

plot(meanSES.2loc.norm_Tipic, modeled_param_norm.loc, pch = 16, col = rgb(0, 0, 0, 0.6),
     xlim = c(min(c(unlist(meanSES.2loc.norm_Tipic), unlist(meanSES.2loc.uni_Tipic)), 
              na.rm = T), 0),
     ylim = c(min(c(modeled_param_norm.loc, modeled_param_uni.loc), na.rm = T), 
              max(c(modeled_param_norm.loc, modeled_param_uni.loc), na.rm = T)),
     main = "Local T_IP.IC",
     xlab = "standardized effect size of T_IP.IC",
     ylab = "modeled parameters: range/sd")
abline(v = mean(SES.inf.MEAN.norm_Tipic, na.rm = T))

points(meanSES.2loc.uni_Tipic, modeled_param_uni.loc, pch = 16, col = rgb(0.5, 0, 1, 0.6))
abline(v = mean(SES.inf.MEAN.uni_Tipic, na.rm = T), col = "purple")
rect(mean(SES.inf.MEAN.norm_Tipic, na.rm = T), -1, 0, max(modeled_param_norm.loc) + 1, 
     col = rgb(0, 0, 0, 0.3), border = NA)
rect(mean(SES.inf.MEAN.uni_Tipic, na.rm = T), 0, 0, max(modeled_param_uni.loc), 
     col = rgb(0.5, 0, 1, 0.3), border = NA)
@

There is a very hich correlation coefficient between initial and modeled parameter either for the range (trait a: Pearson correlation = \Sexpr{round(cor.test(param_DIST_between_MEAN, modeled_param_norm)[[4]], 3)}; trait b: Pearson correlation = \Sexpr{round(cor.test(param_DIST_between_MEAN, modeled_param_uni)[[4]], 3)}) and for the standard error(trait a and b: Pearson correlation = \Sexpr{round(cor.test(sd_mean.param, mean_sd_of_com)[[4]], 3)}). Consequently the consistency between the figures \ref{fig:In_filter_results_plot_initparam} and  \ref{fig:In_filter_results_plot_modeledparam} is not suprising. 
 
 \subsubsection {Global p-values results for $T_{IP/IC}$}
In contrast with local p-values, we call global p-values the p-values corresponding to one indice for one trait across all the communities. 

  \subsubsubsection {Global $T_{IP/IC}$ SES values against initial parameter values}
  
Again, this first results mix different initial parameter values. Now, we can plot the SES values in relation to the strength of the internal filter assessed by the two parameters (either the initial values: \texttt{mean\_range\_between\_com} and \texttt{mean\_sd\_of\_com} or the modeled values \texttt{mean\_{}range\_{}com} and \texttt{sd.com\_{}stock2} \footnote{This modeled values are stochastic versions of the initial values.}). 

First, we need to compute the SES values from simulations.
<<Internal_filter_Results_SES>>= 
meanSES.2glob.norm_Tipic <- unlist(lapply(res.simu2, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_1$ses[,1], na.rm = T)))
meanSES.2glob.uni_Tipic <- unlist(lapply(res.simu2, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_1$ses[,2], na.rm = T)))

meanSES.INF_glob.norm_Tipic <- unlist(lapply(res.simu2, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_1$ses.inf[, 1], na.rm = T)))
meanSES.INF_glob.uni_Tipic <- unlist(lapply(res.simu2, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_1$ses.inf[, 2], na.rm = T)))
@

Plot the result against initial parameters (Fig. \ref{fig:Internal_filter_Results_plots_initial_param}).


<<Internal_filter_Results_plots_initial_param, fig.height = 4, fig.cap = "Global $T_{IP/IC}$ SES and initial parameters values: Standardized effect size of $T_{IP/IC}$ in function of the strength of internal filter defined by the ratio of the inital range parameter by the initial standard error parameter. Colored area represent the mean confidence interval of SES values ($alpha = 0.95$). Trait a (normal) in black and b (uniform) in purple.", dev ='png', dpi = 100, fig.scap = "Global $T_{IP/IC}$ SES and initial parameters values">>= 
plot(meanSES.2glob.norm_Tipic, init_param, pch = 16, col = rgb(0, 0, 0, 0.6),
     main = "Global T_IP.IC",
     xlim = c(min(c(meanSES.2glob.norm_Tipic, meanSES.2glob.uni_Tipic), 
            na.rm = T), 0),
     xlab = "standardized effect size of T_IP.IC",
     ylab = "initial parameters: range/sd")
points(meanSES.2glob.uni_Tipic, init_param, pch = 16, col = rgb(0.5, 0, 1, 0.6),)
abline(v = mean(meanSES.INF_glob.norm_Tipic, na.rm = T))
abline(v = mean(meanSES.INF_glob.uni_Tipic, na.rm = T), col = "purple")
rect(mean(meanSES.INF_glob.norm_Tipic, na.rm = T), -1, 0, max(modeled_param_norm.loc) + 1, 
     col = rgb(0, 0, 0, 0.3), border = NA)
rect(mean(meanSES.INF_glob.uni_Tipic, na.rm = T), 0, 0, max(modeled_param_uni.loc), 
     col = rgb(0.5, 0, 1, 0.3), border = NA)
@



  \subsubsubsection {Global $T_{IP/IC}$ SES values against modeled parameter values}
  
We can verify the consistency of our results by plotting SES values against the modeled parameters values (Fig. \ref{fig:Internal_filter_Results_plots_modeled_param} and \ref{fig:Internal_filter_Results_plots_modeled_param2}). 

<<Internal_filter_Results_plots_modeled_param, fig.height = 4, fig.cap = "Global $T_{IP/IC}$ SES and modeled parameters values: Standardized effect size of $T_{IP/IC}$ in function of the strength of internal filter defined by the ratio of the modeled range parameter by the modeled standard error parameter. Colored area represent the mean confidence interval of SES values ($alpha = 0.95$). Trait a (normal) in black and b (uniform) in purple.", dev ='png', dpi = 100, fig.scap = "Global $T_{IP/IC}$ SES and modeled parameters values">>= 
mean_dist_sp.interm <- t(matrix(unlist(lapply(mean_dist_sp, function(x) x)), nrow = 2))
mean_sd_of_com <- unlist(lapply(sd.sp_stock2, function(x) mean(x)))

modeled_param_norm <- mean_dist_sp.interm[, 1] / mean_sd_of_com 
modeled_param_uni <- mean_dist_sp.interm[, 2] / mean_sd_of_com 

plot(meanSES.2glob.norm_Tipic, modeled_param_norm, pch = 16,
     main = "Global T_IP.IC",
     xlim = c(min(c(meanSES.2glob.norm_Tipic, meanSES.2glob.uni_Tipic), 
              na.rm = T), 0),
     ylim = c(min(c(modeled_param_norm, modeled_param_uni), na.rm = T), 
     max(c(modeled_param_norm, modeled_param_uni), na.rm = T)),
     xlab = "standardized effect size of T_IP.IC",
     ylab = "modeled parameters: range/sd")
points(meanSES.2glob.uni_Tipic, modeled_param_uni, pch = 16, col = rgb(0.5, 0, 1, 0.6))
abline(v = mean(meanSES.INF_glob.norm_Tipic, na.rm = T))
abline(v = mean(meanSES.INF_glob.uni_Tipic, na.rm = T), col = "purple")
rect(mean(meanSES.INF_glob.norm_Tipic, na.rm = T), -1, 0, max(modeled_param_norm) + 1, 
     col = rgb(0, 0, 0, 0.3), border = NA)
rect(mean(meanSES.INF_glob.uni_Tipic, na.rm = T), 0, 0, max(modeled_param_uni), 
     col = rgb(0.5, 0, 1, 0.3), border = NA)
@

  \subsection {Conclusion on the power of $T_{IP/IC}$ to detect internal filtering}

To conclude on the power of $T_{IP/IC}$ to detect internal filtering, we compute exponential linear model and identify the strength from which the beta-error is inferior to 0.05. This strength is defined by the two ratio of the initial parameters \texttt{param\_DIST\_between\_MEAN} and \texttt{sd\_mean.param}. 

<<In_conc_plot, fig.cap = "Power of $T_{IP/IC}$ to detect internal filtering: Standardised Effect Size (SES) of $T_{IP/IC}$ in relation to the strength of internal filtering. Trait 'a' normally distributed is shown in black, traits 'b' uniformally distributed in purple. Open circle represent local SES values wheras close one represent global SES values. The exponential linear model is presented with 5 percents confidence interval on both side. Colored area represent the mean confidence interval of SES values ($alpha = 0.95$)", fig.scap = "Power of $T_{IP/IC}$ to detect internal filtering", dev ='png', dpi = 100>>=
plot(meanSES.2loc.norm_Tipic ~ init_param.loc, col = rgb(0, 0, 0, 0.2), 
     ylim = c(min(c(meanSES.2loc.norm_Tipic , meanSES.2loc.uni_Tipic,
                  meanSES.2glob.norm_Tipic, meanSES.2glob.uni_Tipic), na.rm = T), 0),
     main = "T_IP.IC",
     ylab = "standardized effect size of T_IP.IC",
     xlab = "initial parameters: range/sd",
     type = "n")
#points(meanSES.2loc.uni_Tipic ~ init_param.loc, col = rgb(0.5, 0, 1, 0.2))

points(meanSES.2glob.norm_Tipic ~ init_param, pch = 16, col = rgb(0, 0, 0, 0.5), 
       cex = 1.2)
lm.norm <- lm(meanSES.2glob.norm_Tipic ~ log(init_param))
lm.norm_conf <- confint(lm.norm, level = 0.90)
curve(lm.norm$coef[1] + log(x) * (lm.norm$coef[2]), add = T, lwd = 3)
curve(lm.norm_conf [1, 1] + log(x) * lm.norm_conf [2, 1], add = T, lty = 2)
curve(lm.norm_conf [1, 2] + log(x) * lm.norm_conf [2, 2], add = T, lty = 2)

points(meanSES.2glob.uni_Tipic ~ init_param, pch = 16, col = rgb(0.5, 0, 1, 0.5),
       cex = 1.2)
lm.uni <- lm(meanSES.2glob.uni_Tipic ~ log(init_param))
lm.uni_conf <- confint(lm.uni, level = 0.90)
curve(lm.uni$coef[1] + log(x) * (lm.uni$coef[2]), add = T, lwd = 3, 
      col = rgb(0.5, 0, 1, 1))
curve(lm.uni_conf [1, 1] + log(x) * lm.uni_conf [2, 1], add = T, lty = 2, 
      col = rgb(0.5, 0, 1, 1))
curve(lm.uni_conf [1, 2] + log(x) * lm.uni_conf [2, 2], add = T, lty = 2,
      col = rgb(0.5, 0, 1, 1))


rect(-1, mean(c(SES.inf.MEAN.uni_Tipic, meanSES.INF_glob.uni_Tipic), na.rm = T), 
     max(init_param), 10, col = rgb(0.5, 0, 1, 0.3), border = NA)

rect(-1, mean(c(SES.inf.MEAN.norm_Tipic, meanSES.INF_glob.norm_Tipic), na.rm = T), 
     max(init_param) + 10, 10, col = rgb(0, 0, 0, 0.3), border = NA)

@

<<In_conc_res>>=
yy.norm <- mean(c(SES.inf.MEAN.norm_Tipic, meanSES.INF_glob.norm_Tipic), na.rm = T)
yy.uni <- mean(c(SES.inf.MEAN.uni_Tipic, meanSES.INF_glob.uni_Tipic), na.rm = T)

param_beta0.05_Tipic.norm <- exp((yy.norm - lm.norm_conf [1, 2]) / lm.norm_conf [2, 2])
param_beta0.05_Tipic.uni <- exp((yy.uni - lm.uni_conf [1, 2]) / lm.uni_conf [2, 2])
@


For the trait "a" normally distributed, the power of $T_{IP/IC}$ is satisfactory if the ratio of the initial parameter is superior to
 \Sexpr{round(param_beta0.05_Tipic.norm, 2)}. For the trait "b" uniformally distributed, this value is \Sexpr{round(param_beta0.05_Tipic.uni, 2)}. 
 Further investigation on real data with different strength of internal filtering are needed to complete these simulated values.

 

























\cleardoublepage

\section{External Filter}

 \subsection {Randomization outline}
 
As for internal filter we modulate the strength of the external filter thanks to two parameters:
we define (i) a gradient of range between communities means traits distributions and (ii) a gradient of the mean variance in communities traits distributions. We expect the external filtering to increase (i) when the range in communities means increase (\textit{i.e.} the environmental gradient is larger) and (ii) when the variance in the communities traits distributions decrease (\textit{i.e.} the environmental gradient is stronger).
\\

In analogy with the internal filtering model, we defined \Sexpr{nb_param_val} values for two parameters:
\\

 (i) \texttt{param\_{}RANGE.init} is a vector of length \Sexpr{nb_param_val} which defined the above range for the mean traits values (the maximum value for the mean is assessed to \Sexpr{max.value_traits}). In decreasing the range of traits values while keeping the same number of communities, there is a decrease in the overlap of the communities traits distributions and consequently an decrease of the impact of external filtering in shaping traits distributions. Thus the mean for each communities is drawn from a normal distribution with standard deviation of \Sexpr{mean_sd.param[1]} (parameter \texttt{mean\_{}sd.param}) and means evenly
\footnote{In fact, we draw this values in a normal distribution with means evenly distributed and with a standard error equal to \texttt{mean\_{}sd.param}}
of \Sexpr{mean_sd.param[1]} distributed between \texttt{max.value\_{}traits - param\_{}RANGE} and \texttt{max.value\_{}traits}.
\\

(ii) \texttt{param\_{}SD} is a vector of length \Sexpr{nb_param_val} which defined the standard deviation of traits distributions for each species. In order to decorrelate the mean and standard deviation of species traits distributions, \texttt{param\_{}SD} is permuted before the analysis. 
\\

 Thus for the trait "a" the trait value for each individual is drawn from a normal distribution with the mean depending on it community attribute. For the trait "b" the trait value for each individual is drawn from a uniform distribution with the range depending on it community attribute.
 
<<External_filter_param>>= 
# Parameter for the range of communities traits distributions
param_range.init <- round(sort(seq(10, 200, length.out = nb_param_val)), 2)
param_range <- rep(param_range.init, N_repet_Param)
mean_sd.param <- rep(10, nperm)

# Parameter for the variance in species mean trait values
param_SD <- seq(10, 100,length.out = nb_param_val)
sd_mean.param <- sample (rep(param_SD, N_repet_Param), 
       size = length(rep(param_SD, N_repet_Param)), replace = F)
sd_sd.param <- rep(10, nperm)
@


<<External_filter, results = 'hide'>>= 
nperm <- N_repet_Param*length(param_SD)

mean_range_com <- list() ; sd.com_stock3 <- list() ; res.simu3 <- list()
res.simu3.pval <- list() ; res.simu.traits3 <- list()

for(n in 1:nperm){#for each permutation

 ex.sp3 <- c()
 ex.com3 <- matrix(0, nrow = 10, ncol = 20)
 for(i in 1: 10){
  ex.com.interm <- table(sample(sp, size = 100, prob = rlnorm(20, 0, sdlog), replace = T))
  ex.com3[i, sp%in% names(ex.com.interm)] <- ex.com.interm
  ex.sp3 <- c(ex.sp3, rep(sp, times = ex.com3[i,]))
 }

 ex.indplot3 <- sort(as.factor(rep(com, 100)))

 #Defining mean and sd by community
 mean_mean.param.interm <- seq(max.value_traits - param_range[n], max.value_traits, 
                               length.out = length(unique(param_range)))

 mean_mean.param <- rep(round(sort(mean_mean.param.interm), 2), N_repet_Param)

 mean.com <- rnorm(length(unique(com)), mean = mean_mean.param, sd = mean_sd.param[n])
 sd.com <- rnorm(length(unique(com)), mean = sd_mean.param[n], sd = sd_sd.param[n]) 

 ex.traits3 <- array(NA, dim = c(1000, 2))
 colnames(ex.traits3) <- paste("trait", c("a", "b"), sep = " ")


 for(c in unique(ex.indplot3)){
  #trait a : normal distribution
  ex.traits3[ex.indplot3 == c, 1] <- 
  rnorm(500, rep(mean.com[unique(ex.indplot3) == c], 500),
    rep(sd.com[unique(ex.indplot3) == c], 500))[1:sum(ex.indplot3 == c)]
 
  #trait b : uniform distribution
  ex.traits3[ex.indplot3 == c, 2] <- 
  runif(500, min = rep(mean.com[unique(ex.indplot3) == c], 500) -
        rep(sd.com[unique(ex.indplot3) == c], 500),
        max = rep(mean.com[unique(ex.indplot3) == c], 500) +
        rep(sd.com[unique(ex.indplot3) == c], 500))[1:sum(ex.indplot3 == c)]
 }

 #stock results
 mean_range_com[[n]] <- c(max(ex.traits3[, 1], na.rm = T) - min(ex.traits3[, 1], na.rm = T),
                          max(ex.traits3[, 2], na.rm = T) - min(ex.traits3[, 2], na.rm = T))
 sd.com_stock3[[n]] <- sd.com

 res.simu.traits3[[n]] <- ex.traits3
 res.simu3[[n]] <- Tstats(ex.traits3, ex.indplot3, ex.sp3)
 res.simu3.pval[[n]] <- sum_Tstats(res.simu3[[n]], type = "p.value")
 print(paste("---", round(n/nperm, 2) * 100, "%", sep = " "))
}#End of simulations
@

 \subsection {Results for simulations of external filtering}

Let's see the result for one typical randomization. We can plot the distribution of traits within species and/or communities thanks to the function \texttt{plotDistri} (Fig. \ref{fig:typical_results_external_filtering1}). 

<<typical_results_external_filtering1, fig.cap = "Distribution of traits for one randomization with external filter: (a) Communities trait distributions for the trait a (normal distribution); (b) Communities trait distributions for the trait b (uniform distribution); (c) Species trait distributions for the trait a; (d) Species trait distributions for the trait b", crop = TRUE>>= 
par(mfrow=c(2, 2))
plotDistri(ex.traits3, rep("all_sp", times = dim(ex.traits3)[1]), ex.indplot3, 
           plot.ask = F, multipanel = F, main = c("a", "b"), leg = c(T, F))
plotDistri(ex.traits3, rep("region", times = dim(ex.traits3)[1]), ex.sp3, plot.ask = F, 
           multipanel = F, main = c("c", "d"), leg = c(T, F))
par(mfrow=c(1, 1))
@

We can also plot the result of the T-statistics for two contrasting case (Fig. \ref{fig:typical_results_external_filtering2}).

<<typical_results_external_filtering2, fig.height = 8, fig.cap = "Results of T-statistics of traits for two randomization with contrasted strength of external filter: $T_{IP/IC}$ in red, $T_{IC/IR}$ in purple and $T_{PC/PR}$ in green. (a) Lower strength of external filtering and (b) higher strength of external filtering.", crop = TRUE>>= 
par(mfrow=c(2, 1))
plot(res.simu3[[1]], main = "a")
plot(res.simu3[[n]], main = "b")
par(mfrow=c(1, 1))
@

 \subsubsection {Local $T_{IC/IR}$ and $T_{PC/PR}$ results}

As for internal filtering, we mingle the p-value for different parameters values. Consequently we plot the standard effect size (SES) of $T_{IC/IR}$ and $T_{PC/PR}$ in relation to the initial parameters values. 

  \subsubsubsection {Local $T_{IC/IR}$ and $T_{PC/PR}$ SES values against initial parameter values}

<<External_filter_results_SES>>= 

#T_IC.IR
meanSES.3loc.norm_Ticir <- unlist(lapply(res.simu3, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_2$ses[, 1]))

meanSES.3loc.uni_Ticir <- unlist(lapply(res.simu3, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_2$ses[, 2]))

SES.inf.MEAN.norm_Ticir <- unlist(lapply(res.simu3, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_2$ses.inf[, 1]))

SES.inf.MEAN.uni_Ticir <- unlist(lapply(res.simu3, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_2$ses.inf[, 2]))

#T_PC.PR
meanSES.3loc.norm_Tpcpr <- unlist(lapply(res.simu3, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_3$ses[, 1]))

meanSES.3loc.uni_Tpcpr <- unlist(lapply(res.simu3, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_3$ses[, 2]))

SES.inf.MEAN.norm_Tpcpr <- unlist(lapply(res.simu3, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_3$ses.inf[, 1]))

SES.inf.MEAN.uni_Tpcpr <- unlist(lapply(res.simu3, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_3$ses.inf[, 2]))
@

Now, we can plot SES of $T_{IC/IR}$ (Fig. \ref{fig:Ex_filter_results_plot_initparam1}) and $T_{PC/PR}$ (Fig. \ref{fig:Ex_filter_results_plot_initparam2}). The trait "a" normally distributed is in black and the uniform traits "b" is in purple. The colored rectangles represent the null model area with alpha = 5\%. Thus, when a point is outside these area, the modeled parameters are strong enough to detect the external filter with a high power (beta-error $ < 0.05$).

<<Ex_filter_results_plot_initparam1, fig.height = 4, fig.cap = "Local $T_{IC/IR}$ SES and initial parameters values: Standardized effect size of $T_{IC/IR}$ in function of the strength of external filter defined by the ratio of the initial range parameter by the initial standard error parameter. Colored area represent the mean confidence interval of SES values ($alpha = 0.95$). Trait a (normal) in black and b (uniform) in purple.", dev ='png', dpi = 100, fig.scap = "Local $T_{IC/IR}$ SES and initial parameters values">>= 
init_param <- param_range / sd_mean.param
#each value is replicate Ncom times (there is Ncom communities for each parameter values)
init_param.loc <- rep(init_param, each = Ncom)

plot(meanSES.3loc.norm_Ticir, init_param.loc, pch = 16, col = rgb(0, 0, 0, 0.6),
     xlim = c(min(c(unlist(meanSES.3loc.norm_Ticir), unlist(meanSES.3loc.uni_Ticir)), 
     na.rm = T), 0),
     main = "Local T_IC.IR",
     xlab = "standardized effect size of T_IC.IR",
     ylab = "initial parameters: range/sd")
abline(v = mean(SES.inf.MEAN.norm_Ticir, na.rm = T))

points(meanSES.3loc.uni_Ticir, init_param.loc, pch = 16, col = rgb(0.5, 0, 1, 0.6))
abline(v = mean(SES.inf.MEAN.uni_Ticir, na.rm = T), col = "purple")
rect(mean(SES.inf.MEAN.norm_Ticir, na.rm = T), -1, 0, max(init_param) + 1, 
     col = rgb(0, 0, 0, 0.3), border = NA)
rect(mean(SES.inf.MEAN.uni_Ticir, na.rm = T),0, 0, max(init_param), 
     col = rgb(0.5, 0, 1, 0.3), border = NA)
@
 
  
<<Ex_filter_results_plot_initparam2, fig.height = 4, fig.cap = "Local $T_{PC/PR}$ SES and initial parameters values: Standardized effect size of $T_{PC/PR}$ in function of the strength of external filter defined by the ratio of the initial range parameter by the initial standard error parameter. Colored area represent the mean confidence interval of SES values ($alpha = 0.95$). Trait a (normal) in black and b (uniform) in purple.", dev ='png', dpi = 100, fig.scap = "Local $T_{PC/PR}$ SES and initial parameters values">>= 
plot(meanSES.3loc.norm_Tpcpr, init_param.loc, pch = 16, col = rgb(0, 0, 0, 0.6),
     xlim = c(min(c(unlist(meanSES.3loc.norm_Tpcpr), unlist(meanSES.3loc.uni_Tpcpr)), 
     na.rm = T), 0),
     main = "Local T_PC.PR",
     xlab = "standardized effect size of T_PC.PR",
     ylab = "initial parameters: range/sd")
abline(v = mean(SES.inf.MEAN.norm_Tpcpr, na.rm = T))

points(meanSES.3loc.uni_Tpcpr, init_param.loc, pch = 16, col = rgb(0.5, 0, 1, 0.6))
abline(v = mean(SES.inf.MEAN.uni_Tpcpr, na.rm = T), col = "purple")
rect(mean(SES.inf.MEAN.norm_Tpcpr, na.rm = T), -1, 0, max(init_param) + 1, 
     col = rgb(0, 0, 0, 0.3), border = NA)
rect(mean(SES.inf.MEAN.uni_Tpcpr, na.rm = T), 0, 0, max(init_param), 
     col = rgb(0.5, 0, 1, 0.3), border = NA)
@
 
For each initial parameters values we can calculate the proportion of case where we do not reject the null hypothesis while this hypothesis is wrong (\textit{i.e.} the Beta-error). The next chunk only shows the calculation for the $T_{IC/IR}$ metrics on the trait "a".

<<Ex_calculate_local_betaerrors, echo = 2>>= 
beta_sd_norm_Ticir <- 
 (unlist(lapply(by(cbind(meanSES.3loc.norm_Ticir, SES.inf.MEAN.norm_Ticir), 
     rep(sd_mean.param, each = Ncom), function(x) x[,1] > x[,2]), 
     function(x) sum(x, na.rm = T)))+1)/(10 * N_repet_Param + 1)
beta_range_norm_Ticir <- 
 (unlist(lapply(by(cbind(meanSES.3loc.norm_Ticir, SES.inf.MEAN.norm_Ticir), 
     rep(param_range, each = Ncom), function(x) x[,1] > x[,2]), 
     function(x) sum(x, na.rm = T)))+1)/(10 * N_repet_Param + 1)
   
beta_sd_uni_Ticir <- 
 (unlist(lapply(by(cbind(meanSES.3loc.uni_Ticir, SES.inf.MEAN.uni_Ticir),
     rep(sd_mean.param, each = Ncom), function(x) x[,1] > x[,2]), 
     function(x) sum(x, na.rm = T)))+1)/(10 * N_repet_Param + 1)
beta_range_uni_Ticir <- 
 (unlist(lapply(by(cbind(meanSES.3loc.uni_Ticir, SES.inf.MEAN.uni_Ticir),
     rep(param_range, each = Ncom), function(x) x[,1] > x[,2]),
     function(x) sum(x, na.rm = T)))+1)/(10 * N_repet_Param + 1)

beta_sd_norm_Tpcpr <- 
 (unlist(lapply(by(cbind(meanSES.3loc.norm_Tpcpr, SES.inf.MEAN.norm_Tpcpr), 
     rep(sd_mean.param, each = Ncom), function(x) x[,1] > x[,2]),
     function(x) sum(x, na.rm = T)))+1)/(10 * N_repet_Param + 1)
beta_range_norm_Tpcpr <- 
 (unlist(lapply(by(cbind(meanSES.3loc.norm_Tpcpr, SES.inf.MEAN.norm_Tpcpr), 
     rep(param_range, each = Ncom), function(x) x[,1] > x[,2]), 
     function(x) sum(x, na.rm = T)))+1)/(10 * N_repet_Param + 1)
   
beta_sd_uni_Tpcpr <- 
 (unlist(lapply(by(cbind(meanSES.3loc.uni_Tpcpr, SES.inf.MEAN.uni_Tpcpr), 
     rep(sd_mean.param, each = Ncom), function(x) x[,1] > x[,2]), 
     function(x) sum(x, na.rm = T)))+1)/(10 * N_repet_Param + 1)
beta_range_uni_Tpcpr <- 
 (unlist(lapply(by(cbind(meanSES.3loc.uni_Tpcpr, SES.inf.MEAN.uni_Tpcpr), 
     rep(param_range, each = Ncom), function(x) x[,1] > x[,2]), 
     function(x) sum(x, na.rm = T)))+1)/(10 * N_repet_Param + 1)

res_beta_Ticir <- rbind(rev(beta_sd_norm_Ticir), rev(beta_sd_uni_Ticir), 
      beta_range_norm_Ticir, beta_range_uni_Ticir)
colnames(res_beta_Ticir) <- paste("str", 1:ncol(res_beta_Ticir))
rownames(res_beta_Ticir) <- c("effect of sd (a)", "effect of sd (b)", 
        "effect of range (a)", "effect of range (b)")

res_beta_Tpcpr <- rbind(rev(beta_sd_norm_Tpcpr), rev(beta_sd_uni_Tpcpr), 
      beta_range_norm_Tpcpr, beta_range_uni_Tpcpr)
colnames(res_beta_Tpcpr) <- paste("str", 1:ncol(res_beta_Tpcpr))
rownames(res_beta_Tpcpr) <- c("effect of sd (a)", "effect of sd (b)", 
        "effect of range (a)", "effect of range (b)")
@

<<Ex_resultsof_local_betaerrors1, results='asis'>>= 
print(xtable(res_beta_Ticir, caption = 'Local beta-error of $T_{IC/IR}$ in function 
             of the strength of external filtering. str: strength. Trait a is 
             normally distributed and trait b is uniformally distributed.', 
             label = "tab:local_beta_error_xtable_ticir"), 
      caption.placement = "top", size = "small")
@

<<Ex_resultsof_local_betaerrors2, results='asis'>>= 
print(xtable(res_beta_Ticir, caption = 'Local beta-error of $T_{PC/PR}$ in function 
             of the strength of external filtering. str: strength. Trait a is 
             normally distributed and trait b is uniformally distributed.', 
             label = "tab:local_beta_error_xtable_tpcpr"), 
      caption.placement = "top", size = "small")
@
 
Now we can see the beta-error for each strength (table \ref{tab:local_beta_error_xtable_ticir} and \ref{tab:local_beta_error_xtable_tpcpr}). A high value of range and a low value of standard error defined a high strength of filtering. For example, in the case of a trait normally distributed, the proportion of false negative is \Sexpr{round(res_beta_Ticir[1, 1]*100, 2)}\% for the higher value of standard errors and thus for the lower strength of external filtering.
 
 
  \subsubsubsection {Local $T_{IC/IR}$ and $T_{PC/PR}$ SES values against modeled parameter values}
  
  First we need to calculate the modeled parameter values. Here again we calculate the strength of external filtering by dividing the range of values in communities by their standard error.
  
<<Ex_filter_modeledparam>>= 
mean_range_com.interm <- t(matrix(unlist(lapply(mean_range_com, function(x) x)), nrow = 2))
mean_sd_of_com <- unlist(lapply(sd.com_stock3, function(x) mean(x)))

modeled_param_norm <- mean_range_com.interm[, 1] / mean_sd_of_com 
modeled_param_uni <- mean_range_com.interm[, 2] / mean_sd_of_com 
modeled_param_norm.loc <- rep(modeled_param_norm, each = Ncom)
modeled_param_uni.loc <- rep(modeled_param_uni, each = Ncom)
@

<<Ex_filter_results_plot_modeledparam1, fig.height = 4, fig.cap = "Local $T_{IC/IR}$ SES and modeled parameters values: Standardized effect size of $T_{IC/IR}$ in function of the strength of external filter defined by the ratio of the modeled range parameter by the modeled standard error parameter. Colored area represent the mean confidence interval of SES values ($alpha = 0.95$). Trait a (normal) in black and b (uniform) in purple.", dev ='png', dpi = 100, fig.scap = "Local $T_{IC/IR}$ SES and modeled parameters values">>= 
plot(meanSES.3loc.norm_Ticir, modeled_param_norm.loc, pch = 16, col = rgb(0, 0, 0, 0.6),
  xlim = c(min(c(unlist(meanSES.3loc.norm_Ticir), unlist(meanSES.3loc.uni_Ticir)), 
    na.rm = T), 0),
    ylim = c(0, min(max(c(modeled_param_norm.loc, modeled_param_uni.loc), na.rm = T), 
                    100)),  main = "Local T_IC.IR",
  xlab = "standardized effect size of T_IC.IR",
  ylab = "modeled parameters: range/sd")
abline(v = mean(SES.inf.MEAN.norm_Ticir, na.rm = T))

points(meanSES.3loc.uni_Ticir, modeled_param_uni.loc, pch = 16, col = rgb(0.5, 0, 1, 0.6))
abline(v = mean(SES.inf.MEAN.uni_Ticir, na.rm = T), col = "purple")

rect(mean(SES.inf.MEAN.norm_Ticir, na.rm = T), -1, 0, max(modeled_param_norm.loc) + 1, 
     col = rgb(0, 0, 0, 0.3), border = NA)
rect(mean(SES.inf.MEAN.uni_Ticir, na.rm = T),0, 0, max(modeled_param_uni.loc), 
     col = rgb(0.5, 0, 1, 0.3), border = NA)
@

<<Ex_filter_results_plot_modeledparam2, fig.height = 4, fig.cap = "Local $T_{PC/PR}$ SES and modeled parameters values: Standardized effect size of $T_{PC/PR}$ in function of the strength of external filter defined by the ratio of the modeled range parameter by the modeled standard error parameter. Colored area represent the mean confidence interval of SES values ($alpha = 0.95$). Trait a (normal) in black and b (uniform) in purple.", dev ='png', dpi = 100, fig.scap = "Local $T_{PC/PR}$ SES and modeled parameters values">>= 
plot(meanSES.3loc.norm_Tpcpr, modeled_param_norm.loc, pch = 16, col = rgb(0, 0, 0, 0.6),
     xlim = c(min(c(unlist(meanSES.3loc.norm_Tpcpr), unlist(meanSES.3loc.uni_Tpcpr)), 
              na.rm = T), 0),
     ylim = c(0, min(max(c(modeled_param_norm.loc, modeled_param_uni.loc), na.rm = T), 
                     100)),
     main = "Local T_PC.PR",
     xlab = "standardized effect size of T_PC.PR",
     ylab = "modeled parameters: range/sd")
abline(v = mean(SES.inf.MEAN.norm_Tpcpr, na.rm = T))

points(meanSES.3loc.uni_Tpcpr, modeled_param_uni.loc, pch = 16, col = rgb(0.5, 0, 1, 0.6))
abline(v = mean(SES.inf.MEAN.uni_Tpcpr, na.rm = T), col = "purple")
rect(mean(SES.inf.MEAN.norm_Tpcpr, na.rm = T), -1, 0, max(modeled_param_norm.loc) + 1, 
     col = rgb(0, 0, 0, 0.3), border = NA)
rect(mean(SES.inf.MEAN.uni_Tpcpr, na.rm = T), 0, 0, max(modeled_param_uni.loc), 
     col = rgb(0.5, 0, 1, 0.3), border = NA)
@

There is a very hich correlation coefficient between initial and modeled parameter either for the range (trait a: Pearson correlation = \Sexpr{round(cor.test(param_range, modeled_param_norm)[[4]], 3)}; trait b: Pearson correlation = \Sexpr{round(cor.test(param_range, modeled_param_uni)[[4]], 3)}) and for the standard error(trait a and b: Pearson correlation = \Sexpr{round(cor.test(sd_mean.param, mean_sd_of_com)[[4]], 3)}). Consequently the consistency between the figures \ref{fig:Ex_filter_results_plot_initparam1} - \ref{fig:Ex_filter_results_plot_initparam2} and \ref{fig:Ex_filter_results_plot_modeledparam1} - \ref{fig:Ex_filter_results_plot_modeledparam2} is not suprising. 
 
 \subsubsection {Global $T_{IC/IR}$ and $T_{PC/PR}$ results}
 
In contrast with local p-values, we call global p-values the p-values corresponding to one indice for one trait across all the communities. 
 
  \subsubsubsection {Calculation of beta-error mixing all strength of filtering}
 
To illustrate the global power of $T_{IC/IR}$ and $T_{PC/PR}$ you can plot the ordered p-values and calculate a beta-error thanks to the code below. It's just an illustration because we mingle very different strength of external filter with different initial parameter values. Plot results are not shown in this document. 
 
<<External_filter_Results_pval_global, eval = FALSE>>= 
par(mfrow = c(2, 2))
xx <- log10(sort(unlist(lapply(res.simu3.pval, function(x) x[21:30, 1]))))
plot(xx, type = "l", main = "T_IC.IR_distriNorm")
abline(h = log10(0.05))
nbre_beta_error <- round((sum(xx>log10(0.05))+1)/(length(xx)+1), 4)
text(0, -0.8, labels = paste("beta error", nbre_beta_error, sep = " = "), cex = 0.7, pos = 4)

xx <- log10(sort(unlist(lapply(res.simu3.pval, function(x) x[41:50, 1]))))
plot(xx, type = "l", main = "T_PC.PR_distriNorm")
abline(h = log10(0.05))
nbre_beta_error <- round((sum(xx>log10(0.05))+1)/(length(xx)+1), 4)
text(0, -0.8, labels = paste("beta error", nbre_beta_error, sep = " = "), cex = 0.7, pos = 4)


xx <- log10(sort(unlist(lapply(res.simu3.pval, function(x) x[21:30, 2]))))
plot(xx, type = "l", main = "T_IC.IR_distriUni")
abline(h = log10(0.05))
nbre_beta_error <- round((sum(xx>log10(0.05))+1)/(length(xx)+1), 4)
text(0, -0.8, labels = paste("beta error", nbre_beta_error, sep = " = "), cex = 0.7, pos = 4)

xx <- log10(sort(unlist(lapply(res.simu3.pval, function(x) x[41:50, 2]))))
plot(xx, type = "l", main = "T_PC.PR_distriUni")
abline(h = log10(0.05))
nbre_beta_error <- round((sum(xx>log10(0.05))+1)/(length(xx)+1), 4)
text(0, -0.8, labels = paste("beta error", nbre_beta_error, sep = " = "), cex = 0.7, pos = 4)

par(mfrow = c(1, 1))
@


  \subsubsubsection {Global $T_{IC/IR}$ and $T_{PC/PR}$ SES values against initial parameter values}
  
Again, this first results mix different initial parameter values. Now, we can plot the SES values in relation to the strength of the external filter assessed by the two parameters (either the initial values: \texttt{mean\_range\_between\_com} and \texttt{mean\_sd\_of\_com} or the modeled values \texttt{mean\_{}range\_{}com} and \texttt{sd.com\_{}stock3} \footnote{This modeled values are stochastic versions of the initial values.}). 

First, we need to compute the SES values from simulations.
<<External_filter_Results_SES>>= 
meanSES.3glob.norm_Ticir <- unlist(lapply(res.simu3, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_2$ses[,1], na.rm = T)))
meanSES.3glob.uni_Ticir <- unlist(lapply(res.simu3, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_2$ses[,2], na.rm = T)))
meanSES.3glob.norm_Tpcpr <- unlist(lapply(res.simu3, function(x)
           mean(ses.listofindex(as.listofindex(x))
             $index_1_3$ses[,1], na.rm = T)))
meanSES.3glob.uni_Tpcpr <- unlist(lapply(res.simu3, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_3$ses[,2], na.rm = T)))

meanSES.INF_glob.norm_Ticir <- unlist(lapply(res.simu3, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_2$ses.inf[, 1], na.rm = T)))
meanSES.INF_glob.uni_Ticir <- unlist(lapply(res.simu3, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_2$ses.inf[, 2], na.rm = T)))
meanSES.INF_glob.norm_Tpcpr <- unlist(lapply(res.simu3, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_3$ses.inf[, 1], na.rm = T)))
meanSES.INF_glob.uni_Tpcpr <- unlist(lapply(res.simu3, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_3$ses.inf[, 2], na.rm = T)))
@

Plot the result against initial parameters (Fig. \ref{fig:External_filter_Results_plots_initial_param1} and \ref{fig:External_filter_Results_plots_initial_param2}).
<<External_filter_Results_plots_initial_param1, fig.height = 4, fig.cap = "Global $T_{IC/IR}$ SES and initial parameters values: Standardized effect size of $T_{IC/IR}$ in function of the strength of external filter defined by the ratio of the inital range parameter by the initial standard error parameter. Colored area represent the mean confidence interval of SES values ($alpha = 0.95$). Trait a (normal) in black and b (uniform) in purple.", dev ='png', dpi = 100, fig.scap = "Global $T_{IC/IR}$ SES and initial parameters values">>= 
init_param <- param_range / sd_mean.param

plot(meanSES.3glob.norm_Ticir, init_param, pch = 16, col = rgb(0, 0, 0, 0.6),
     main = "Global T_IC.IR",
     xlim = c(min(c(meanSES.3glob.norm_Ticir, meanSES.3glob.uni_Ticir), 
             na.rm = T), 0),
     xlab = "standardized effect size of T_IC.IR",
     ylab = "initial parameters: range/sd")
points(meanSES.3glob.uni_Ticir, init_param, pch = 16, col = rgb(0.5, 0, 1, 0.6),)
abline(v = mean(meanSES.INF_glob.norm_Ticir, na.rm = T))
abline(v = mean(meanSES.INF_glob.uni_Ticir, na.rm = T), col = "purple")
rect(mean(meanSES.INF_glob.norm_Ticir, na.rm = T), -1, 0, max(modeled_param_norm.loc) + 1, 
     col = rgb(0, 0, 0, 0.3), border = NA)
rect(mean(meanSES.INF_glob.uni_Ticir, na.rm = T), 0, 0, max(modeled_param_uni.loc), 
     col = rgb(0.5, 0, 1, 0.3), border = NA)
@

<<External_filter_Results_plots_initial_param2, fig.height = 4, fig.cap = "Global $T_{PC/PR}$ SES and initial parameters values: Standardized effect size of $T_{PC/PR}$ in function of the strength of external filter defined by the ratio of the inital range parameter by the initial standard error parameter. Colored area represent the mean confidence interval of SES values ($alpha = 0.95$). Trait a (normal) in black and b (uniform) in purple.", dev ='png', dpi = 100, fig.scap = "Global $T_{PC/PR}$ SES and initial parameters values">>= 
plot(meanSES.3glob.norm_Tpcpr, init_param, pch = 16, col = rgb(0, 0, 0, 0.6),
     main = "Global T_PC.PR",
     xlim = c(min(c(meanSES.3glob.norm_Tpcpr, meanSES.3glob.uni_Tpcpr), 
            na.rm = T), 0),
     xlab = "standardized effect size of T_PC.PR",
     ylab = "initial parameters: range/sd")
points(meanSES.3glob.uni_Tpcpr, init_param, pch = 16, col = rgb(0.5, 0, 1, 0.6))
abline(v = mean(meanSES.INF_glob.norm_Tpcpr, na.rm = T))
abline(v = mean(meanSES.INF_glob.uni_Tpcpr, na.rm = T), col = "purple")
rect(mean(meanSES.INF_glob.norm_Tpcpr, na.rm = T), -1, 0, max(modeled_param_norm.loc) + 1, 
     col = rgb(0, 0, 0, 0.3), border = NA)
rect(mean(meanSES.INF_glob.uni_Tpcpr, na.rm = T), 0, 0, max(modeled_param_uni.loc), 
     col = rgb(0.5, 0, 1, 0.3), border = NA)
@
  
  \subsubsubsection {Global $T_{IC/IR}$ and $T_{PC/PR}$ SES values against modeled parameter values}
  
We can verify the consistency of our results by plotting SES values against the modeled parameters values (Fig. \ref{fig:External_filter_Results_plots_modeled_param1} and \ref{fig:External_filter_Results_plots_modeled_param2}). 

<<External_filter_Results_plots_modeled_param1, fig.height = 4, fig.cap = "Global $T_{IC/IR}$ SES and modeled parameters values: Standardized effect size of $T_{IC/IR}$ in function of the strength of external filter defined by the ratio of the modeled range parameter by the modeled standard error parameter. Colored area represent the mean confidence interval of SES values ($alpha = 0.95$). Trait a (normal) in black and b (uniform) in purple.", dev ='png', dpi = 100, fig.scap = "Global $T_{IC/IR}$ SES and modeled parameters values">>= 
mean_range_com.interm <- t(matrix(unlist(lapply(mean_range_com, function(x) x)), nrow = 2))
mean_sd_of_com <- unlist(lapply(sd.com_stock3, function(x) mean(x)))

modeled_param_norm <- mean_range_com.interm[, 1] / mean_sd_of_com 
modeled_param_uni <- mean_range_com.interm[, 2] / mean_sd_of_com 

plot(meanSES.3glob.norm_Ticir, modeled_param_norm, pch = 16, 
  main = "Global T_IC.IR",
  xlim = c(min(c(meanSES.3glob.norm_Ticir, meanSES.3glob.uni_Ticir), na.rm = T), 0),
  ylim = c(0, min(max(c(modeled_param_norm, modeled_param_uni), na.rm = T), 100)),
  xlab = "standardized effect size of T_IC.IR",
  ylab = "modeled parameters: range/sd")
points(meanSES.3glob.uni_Ticir, modeled_param_uni, pch = 16, col = rgb(0.5, 0, 1, 0.6))
abline(v = mean(meanSES.INF_glob.norm_Ticir, na.rm = T))
abline(v = mean(meanSES.INF_glob.uni_Ticir, na.rm = T), col = "purple")
rect(mean(meanSES.INF_glob.norm_Ticir, na.rm = T), -1, 0, max(modeled_param_norm) + 1, 
  col = rgb(0, 0, 0, 0.3), border = NA)
rect(mean(meanSES.INF_glob.uni_Ticir, na.rm = T), 0, 0, max(modeled_param_uni), 
  col = rgb(0.5, 0, 1, 0.3), border = NA)
@

<<External_filter_Results_plots_modeled_param2, fig.height = 4, fig.cap = "Global $T_{PC/PR}$ SES and modeled parameters values: Standardized effect size of $T_{PC/PR}$ in function of the strength of external filter defined by the ratio of the modeled range parameter by the modeled standard error parameter. Colored area represent the mean confidence interval of SES values ($alpha = 0.95$). Trait a (normal) in black and b (uniform) in purple.", dev ='png', dpi = 100, fig.scap = "Global $T_{PC/PR}$ SES and modeled parameters values">>= 
plot(meanSES.3glob.norm_Tpcpr, modeled_param_norm, pch = 16,
  main = "Global T_PC.PR",
  xlim = c(min(c(meanSES.3glob.norm_Tpcpr, meanSES.3glob.uni_Tpcpr), 
    na.rm = T), 0),
  ylim = c(0, min(max(c(modeled_param_norm, modeled_param_uni), na.rm = T), 100)),
  xlab = "standardized effect size of T_PC.PR",
  ylab = "modeled parameters: range/sd")
points(meanSES.3glob.uni_Tpcpr, modeled_param_uni, pch = 16, col = rgb(0.5, 0, 1, 0.6))
abline(v = mean(meanSES.INF_glob.norm_Tpcpr, na.rm = T))
abline(v = mean(meanSES.INF_glob.uni_Tpcpr, na.rm = T), col = "purple")
rect(mean(meanSES.INF_glob.norm_Tpcpr, na.rm = T), -1, 0, max(modeled_param_norm) + 1, 
  col = rgb(0, 0, 0, 0.3), border = NA)
rect(mean(meanSES.INF_glob.uni_Tpcpr, na.rm = T), 0, 0, max(modeled_param_uni), 
  col = rgb(0.5, 0, 1, 0.3), border = NA)
@


  \subsection {Conclusion on the power of $T_{IC/IR}$ to detect external filtering}

To conclude on the power of $T_{IC/IR}$ to detect external filtering, we compute exponential linear model and identify the strength from which the beta-error is inferior to 0.05. This strength is define by the two ratio of the initial parameters \texttt{param\_range} and \texttt{sd\_mean.param}. 

<<Ex_conc_plot1, fig.cap = "Power of $T_{IC/IR}$ to detect external filtering: Standardised Effect Size (SES) of $T_{IC/IR}$ in relation to the strength of external filtering. Trait 'a' normally distributed is shown in black, traits 'b' uniformally distributed in purple. Close circles represent global SES values. The exponential linear model is presented with 5 percents confidence interval on both side. Colored area represent the mean confidence interval of SES values ($alpha = 0.95$)", fig.scap = "Power of $T_{IC/IR}$ to detect external filtering", dev ='png', dpi = 100>>=
plot(meanSES.3loc.norm_Ticir ~ init_param.loc, col = rgb(0, 0, 0, 0.2), 
     ylim = c(min(c(meanSES.3loc.norm_Ticir , meanSES.3loc.uni_Ticir,
                  meanSES.3glob.norm_Ticir, meanSES.3glob.uni_Ticir), na.rm = T), 0),
     main = "Global T_IC.IR",
     ylab = "standardized effect size of T_IC.IR",
     xlab = "initial parameters: range/sd",
     type = "n")
#points(meanSES.3loc.uni_Ticir ~ init_param.loc, col = rgb(0.5, 0, 1, 0.2))

points(meanSES.3glob.norm_Ticir ~ init_param, pch = 16, col = rgb(0, 0, 0, 0.5), cex = 1.2)
lm.norm <- lm(meanSES.3glob.norm_Ticir ~ log(init_param))
lm.norm_conf <- confint(lm.norm, level = 0.90)
curve(lm.norm$coef[1] + log(x) * (lm.norm$coef[2]), add = T, lwd = 3, col = rgb(0, 0, 0, 1))
curve(lm.norm_conf [1, 1] + log(x) * lm.norm_conf [2, 1], add = T, lty = 2, col = rgb(0, 0, 0, 1))
curve(lm.norm_conf [1, 2] + log(x) * lm.norm_conf [2, 2], add = T, lty = 2, col = rgb(0, 0, 0, 1))

points(meanSES.3glob.uni_Ticir ~ init_param, pch = 16, col = rgb(0.5, 0, 1, 0.5), cex = 1.2)
lm.uni <- lm(meanSES.3glob.uni_Ticir ~ log(init_param))
lm.uni_conf <- confint(lm.uni, level = 0.90)
curve(lm.uni$coef[1] + log(x) * (lm.uni$coef[2]), add = T, lwd = 3,  col = rgb(0.5, 0, 1, 1))
curve(lm.uni_conf [1, 1] + log(x) * lm.uni_conf [2, 1], add = T, lty = 2, col = rgb(0.5, 0, 1, 1))
curve(lm.uni_conf [1, 2] + log(x) * lm.uni_conf [2, 2], add = T, lty = 2, col = rgb(0.5, 0, 1, 1))


rect(-1, mean(c(SES.inf.MEAN.uni_Ticir, meanSES.INF_glob.uni_Ticir), na.rm = T), max(init_param), 10, 
  col = rgb(0.5, 0, 1, 0.3), border = NA)

rect(-1, mean(c(SES.inf.MEAN.norm_Ticir, meanSES.INF_glob.norm_Ticir), na.rm = T), max(init_param) + 10, 10, 
  col = rgb(0, 0, 0, 0.3), border = NA)

@

<<Ex_conc_res1>>=
yy.norm <- mean(c(SES.inf.MEAN.norm_Ticir, meanSES.INF_glob.norm_Ticir), na.rm = T)
yy.uni <- mean(c(SES.inf.MEAN.uni_Ticir, meanSES.INF_glob.uni_Ticir), na.rm = T)

param_beta0.05_Ticir.norm <- exp( (yy.norm - lm.norm_conf [1, 2]) / lm.norm_conf [2, 2] )
param_beta0.05_Ticir.uni <- exp( (yy.uni - lm.uni_conf [1, 2]) / lm.uni_conf [2, 2] )
@


For the trait "a" normally distributed, the power of $T_{IC/IR}$ is satisfactory if the ratio of the initial parameter is superior to
 \Sexpr{round(param_beta0.05_Ticir.norm, 2)}. For the trait "b" uniformally distributed, this value is \Sexpr{round(param_beta0.05_Ticir.uni, 2)}. 
 Further investigation on real data with different strength of external filtering are needed to complete these simulated values.

 




  \subsection {Conclusion on the power of $T_{PC/PR}$ to detect external filtering}

To conclude on the power of $T_{PC/PR}$ to detect external filtering, we compute exponential linear model and identify the strength from which the beta-error is inferior to 0.05. This strength is define by the two ratio of the initial parameters \texttt{param\_range} and \texttt{sd\_mean.param}. 

<<Ex_conc_plot2, fig.cap = "Power of $T_{PC/PR}$ to detect external filtering: Standardised Effect Size (SES) of $T_{PC/PR}$ in relation to the strength of external filtering. Trait 'a' normally distributed is shown in black, traits 'b' uniformally distributed in purple. Close circles represent global SES values. The exponential linear model is represented with 5 percents confidence interval on both side. Colored area represent the mean confidence interval of SES values ($alpha = 0.95$)", fig.scap = "Power of $T_{PC/PR}$ to detect external filtering", dev ='png', dpi = 100>>=
plot(meanSES.3loc.norm_Tpcpr ~ init_param.loc, col = rgb(0, 0, 0, 0.2), 
     ylim = c(min(c(meanSES.3loc.norm_Tpcpr , meanSES.3loc.uni_Tpcpr,
                  meanSES.3glob.norm_Tpcpr, meanSES.3glob.uni_Tpcpr), na.rm = T), 0),
     main = "Global T_PC.IR",
     ylab = "standardized effect size of T_PC.IR",
     xlab = "initial parameters: range/sd",
     type = "n")
#points(meanSES.3loc.uni_Tpcpr ~ init_param.loc, col = rgb(0.5, 0, 1, 0.2))

points(meanSES.3glob.norm_Tpcpr ~ init_param, pch = 16, col = rgb(0, 0, 0, 0.5), cex = 1.2)
lm.norm <- lm(meanSES.3glob.norm_Tpcpr ~ log(init_param))
lm.norm_conf <- confint(lm.norm, level = 0.90)
curve(lm.norm$coef[1] + log(x) * (lm.norm$coef[2]), add = T, lwd = 3, col = rgb(0, 0, 0, 1))
curve(lm.norm_conf [1, 1] + log(x) * lm.norm_conf [2, 1], add = T, lty = 2, col = rgb(0, 0, 0, 1))
curve(lm.norm_conf [1, 2] + log(x) * lm.norm_conf [2, 2], add = T, lty = 2, col = rgb(0, 0, 0, 1))

points(meanSES.3glob.uni_Tpcpr ~ init_param, pch = 16, col = rgb(0.5, 0, 1, 0.5), cex = 1.2)
lm.uni <- lm(meanSES.3glob.uni_Tpcpr ~ log(init_param))
lm.uni_conf <- confint(lm.uni, level = 0.90)
curve(lm.uni$coef[1] + log(x) * (lm.uni$coef[2]), add = T, lwd = 3,  col = rgb(0.5, 0, 1, 1))
curve(lm.uni_conf [1, 1] + log(x) * lm.uni_conf [2, 1], add = T, lty = 2, col = rgb(0.5, 0, 1, 1))
curve(lm.uni_conf [1, 2] + log(x) * lm.uni_conf [2, 2], add = T, lty = 2, col = rgb(0.5, 0, 1, 1))


rect(-1, mean(c(SES.inf.MEAN.uni_Tpcpr, meanSES.INF_glob.uni_Tpcpr), na.rm = T), max(init_param), 10, 
  col = rgb(0.5, 0, 1, 0.3), border = NA)

rect(-1, mean(c(SES.inf.MEAN.norm_Tpcpr, meanSES.INF_glob.norm_Tpcpr), na.rm = T), max(init_param) + 10, 10, 
  col = rgb(0, 0, 0, 0.3), border = NA)

@

<<Ex_conc_res2>>=
yy.norm <- mean(c(SES.inf.MEAN.norm_Tpcpr, meanSES.INF_glob.norm_Tpcpr), na.rm = T)
yy.uni <- mean(c(SES.inf.MEAN.uni_Tpcpr, meanSES.INF_glob.uni_Tpcpr), na.rm = T)

param_beta0.05_Tpcpr.norm <- exp( (yy.norm - lm.norm_conf [1, 2]) / lm.norm_conf [2, 2] )
param_beta0.05_Tpcpr.uni <- exp( (yy.uni - lm.uni_conf [1, 2]) / lm.uni_conf [2, 2] )
@


For the trait "a" normally distributed, the power of $T_{PC/PR}$ is satisfactory if the ratio of the initial parameter is superior to
 \Sexpr{round(param_beta0.05_Tpcpr.norm, 2)}. For the trait "b" uniformally distributed, this value is \Sexpr{round(param_beta0.05_Tpcpr.uni, 2)}. 
 Further investigation on real data with different strength of external filtering are needed to complete these simulated values. As expected, $T_{PC/PR}$ is far less powerfull than $T_{IC/IR}$ to detect external filtering either with traits "a" (\Sexpr{round(param_beta0.05_Tpcpr.norm, 2)} \textit{vs} \Sexpr{round(param_beta0.05_Ticir.norm, 2)}) and "b" (\Sexpr{round(param_beta0.05_Tpcpr.uni, 2)} \textit{vs} \Sexpr{round(param_beta0.05_Ticir.uni, 2)}). This is due to the loss of information in $T_{PC/PR}$ when we compute the mean by population and exclude intra-populationnal variation from the test of external filter. 




































\cleardoublepage

\section{Internal and external filtering}

  \subsection{Randomization outline}
We use the same two parameters as for internal and external filtering analysis. The internal filtering is computed as in the section dedicated to internal filter. To add the effect of external filtering, we add a value to each individual belonging to a community, this values differing among communities.

<<Internal_and_external_filter_parameter>>= 
# Parameter for the distance between species mean trait values
param_DIST_between_MEAN.init <- round(sort(seq(10, 200, length.out = nb_param_val)), 2)
param_DIST_between_MEAN <- rep(param_DIST_between_MEAN.init, N_repet_Param)
mean_sd.param <- rep(10, nperm)

# Parameter for the variance in species mean trait values
param_SD <- seq(10, 100,length.out = nb_param_val)
sd_mean.param <- sample (rep(param_SD, N_repet_Param), 
       size = length(rep(param_SD, N_repet_Param)), replace = F)
sd_sd.param <- rep(10, nperm)

nperm <- N_repet_Param*length(param_SD)
@

<<Internal_and_external_filter, results = 'hide'>>= 
#Start simulation 
mean.sp_stock4 <- list()
sd.sp_stock4 <- list()
mean.com_stock4 <- list()
sd.com_stock4 <- list()
res.simu4 <- list()
res.simu4.pval <- list()
res.simu.traits4 <- list()

for(n in 1:nperm){#for each permutation

ex.sp4 <- c()
ex.com4 <- matrix(0, nrow = 10, ncol = 20)
for(i in 1: 10){
 ex.com.interm <- table(sample(sp, size = 100, prob = rlnorm(20, 0, sdlog), replace = T))
 ex.com4[i, sp%in% names(ex.com.interm)] <- ex.com.interm
 ex.sp4 <- c(ex.sp4, rep(sp, times = ex.com4[i,]))
}

ex.indplot4 <- sort(as.factor(rep(com, 100)))


#Defining traits mean and sd by species 
mean_mean.param.interm <- seq(max.value_traits - param_DIST_between_MEAN[n],
        max.value_traits, length.out = 
        length(unique(param_DIST_between_MEAN)))

mean_mean.param <- rep(round(sort(mean_mean.param.interm), 2),
        N_repet_Param)

mean.sp <- rnorm(length(unique(sp)), mean = mean_mean.param, sd = mean_sd.param[n])
sd.sp <- rnorm(length(unique(sp)), mean = sd_mean.param[n], sd = sd_sd.param[n]) 

ex.traits4 <- array(NA, dim = c(1000, 2))
colnames(ex.traits4) <- paste("trait", c("a", "b"), sep = " ")

for(s in unique(ex.sp4)){
 #trait a : normal distribution
 ex.traits4[ex.sp4 == s, 1] <- rnorm(500, rep(mean.sp[unique(ex.sp4) == s], 500), 
         rep(sd.sp[unique(ex.sp4) == s], 500))[1:sum(ex.sp4 == s)]
 
 #trait b : uniform distribution
 ex.traits4[ex.sp4 == s, 2] <- runif(500, min = rep(mean.sp[unique(ex.sp4) == s], 500) - 
         rep(sd.sp[unique(ex.sp4) == s], 500), 
         max = rep(mean.sp[unique(ex.sp4) == s], 500) + 
         rep(sd.sp[unique(ex.sp4) == s], 500))[1:sum(ex.sp4 == s)]
}

mean.com.add <- rnorm(length(unique(com)), mean = mean_mean.param, sd = mean_sd.param[n])
sd.com.add <- rnorm(length(unique(com)), mean = sd_mean.param[n], sd = sd_sd.param[n]) 

for(c in unique(ex.indplot4)){
 #trait a : normal distribution
 ex.traits4[ex.indplot4 == c, 1] <- 
 ex.traits4[ex.indplot4 == c, 1] + 
 rnorm(500, rep(mean.com.add[unique(ex.indplot4) == c], 500),
 rep(sd.com.add [unique(ex.indplot4) == c], 500))[1:sum(ex.indplot4 == c)]
 
 #trait b : uniform distribution 
 ex.traits4[ex.indplot4 == c, 2] <- 
 ex.traits4[ex.indplot4 == c, 2] + 
 runif(500, min = rep(mean.com.add[unique(ex.indplot4) == c], 500) - 
 rep(sd.com.add[unique(ex.indplot4) == c], 500), 
 max = rep(mean.com.add [unique(ex.indplot4) == c], 500) + 
 rep(sd.com.add [unique(ex.indplot4) == c], 500))[1:sum(ex.indplot4 == c)]
}

#stock results
mean.sp_stock4[[n]] <- mean.sp 
sd.sp_stock4[[n]] <- sd.sp

mean.com_stock4[[n]] <- mean.com.add
sd.com_stock4[[n]] <- sd.com.add 

res.simu.traits4[[n]] <- ex.traits4
res.simu4[[n]] <- Tstats(ex.traits4, ex.indplot4, ex.sp4)
res.simu4.pval[[n]] <- sum_Tstats(res.simu4[[n]], type = "p.value")
print(paste("---", round(n/nperm, 2) * 100, "%", sep = " "))
}#End of simulations
@



  \subsection{Results}
<<InEx_Filter_plots, fig.cap = "Distribution of traits for one randomization with both internal and external filter: (a) Communities trait distributions for the trait a (normal distribution); (b) Communities trait distributions for the trait b (uniform distribution); (c) Species trait distributions for the trait a; (d) Species trait distributions for the trait b", crop = TRUE>>= 
par(mfrow=c(2, 2))
plotDistri(ex.traits4, rep("all_sp", times = dim(ex.traits1)[1]), ex.indplot4, 
           plot.ask = F, multipanel = F, leg =c(T, F), main = c("a", "b"))
plotDistri(ex.traits4, rep("region", times = dim(ex.traits1)[1]), ex.sp4, 
           plot.ask = F, multipanel = F, leg =c(T, F), main = c("c", "d"), 
           ylim = c(0, 0.01))
par(mfrow=c(1, 1))
@

<<InEx_Filter_plots_Tstats, fig.height = 8, fig.cap = "Results of T-statistics with both internal and external filter: $T_{IP/IC}$ in red, $T_{IC/IR}$ in purple and $T_{PC/PR}$ in green. (a) Lower strength of internal filtering 5 (b) higher strength of internal filtering.", crop = TRUE>>= 
par(mfrow=c(3, 1))
plot(res.simu4[[1]], main = "a")
plot(res.simu4[[nperm/2]], main = "b")
plot(res.simu4[[nperm]], main = "c")
par(mfrow=c(1, 1))
@
  

<<ExIn_filter_locresults_SES>>= 
meanSES.4loc.norm_Tipic <- unlist(lapply(res.simu4, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_1$ses[, 1]))
meanSES.4loc.uni_Tipic <- unlist(lapply(res.simu4, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_1$ses[, 2]))
SES.inf.MEAN.norm_Tipic <- unlist(lapply(res.simu4, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_1$ses.inf[, 1]))
SES.inf.MEAN.uni_Tipic <- unlist(lapply(res.simu4, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_1$ses.inf[, 2]))

meanSES.4loc.norm_Ticir <- unlist(lapply(res.simu4, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_2$ses[, 1]))
meanSES.4loc.uni_Ticir <- unlist(lapply(res.simu4, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_2$ses[, 2]))
SES.inf.MEAN.norm_Ticir <- unlist(lapply(res.simu4, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_2$ses.inf[, 1]))
SES.inf.MEAN.uni_Ticir <- unlist(lapply(res.simu4, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_2$ses.inf[, 2]))

meanSES.4loc.norm_Tpcpr <- unlist(lapply(res.simu4, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_3$ses[, 1]))
meanSES.4loc.uni_Tpcpr <- unlist(lapply(res.simu4, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_3$ses[, 2]))
SES.inf.MEAN.norm_Tpcpr <- unlist(lapply(res.simu4, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_3$ses.inf[, 1]))
SES.inf.MEAN.uni_Tpcpr <- unlist(lapply(res.simu4, function(x) 
             ses.listofindex(as.listofindex(x))
             $index_1_3$ses.inf[, 2]))
@


<<ExIn_filter_globresults_SES>>=  
meanSES.4glob.norm_Tipic <- unlist(lapply(res.simu4, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_1$ses[,1], na.rm = T)))
meanSES.4glob.uni_Tipic <- unlist(lapply(res.simu4, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_1$ses[,2], na.rm = T)))
meanSES.INF_glob.norm_Tipic <- unlist(lapply(res.simu4, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_1$ses.inf[, 1], na.rm = T)))
meanSES.INF_glob.uni_Tipic <- unlist(lapply(res.simu4, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_1$ses.inf[, 2], na.rm = T)))

meanSES.4glob.norm_Ticir <- unlist(lapply(res.simu4, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_2$ses[,1], na.rm = T)))
meanSES.4glob.uni_Ticir <- unlist(lapply(res.simu4, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_2$ses[,2], na.rm = T)))
meanSES.INF_glob.norm_Ticir <- unlist(lapply(res.simu4, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_2$ses.inf[, 1], na.rm = T)))
meanSES.INF_glob.uni_Ticir <- unlist(lapply(res.simu4, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_2$ses.inf[, 2], na.rm = T)))

meanSES.4glob.norm_Tpcpr <- unlist(lapply(res.simu4, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_3$ses[,1], na.rm = T)))
meanSES.4glob.uni_Tpcpr <- unlist(lapply(res.simu4, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_3$ses[,2], na.rm = T)))
meanSES.INF_glob.norm_Tpcpr <- unlist(lapply(res.simu4, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_3$ses.inf[, 1], na.rm = T)))
meanSES.INF_glob.uni_Tpcpr <- unlist(lapply(res.simu4, function(x) 
           mean(ses.listofindex(as.listofindex(x))
             $index_1_3$ses.inf[, 2], na.rm = T)))


@



<<ExIn_filter_globresults_lm>>=  

# trait a
lm_glob_norm_Tipic <- lm(meanSES.4glob.norm_Tipic ~ log(init_param))
lm_glob_norm_Tipic.conf <- confint(lm_glob_norm_Tipic , level = 0.90)
lm_glob_norm_Ticir <- lm(meanSES.4glob.norm_Ticir ~ log(init_param))
lm_glob_norm_Ticir.conf <- confint(lm_glob_norm_Ticir , level = 0.90)
lm_glob_norm_Tpcpr <- lm(meanSES.4glob.norm_Tpcpr ~ log(init_param))
lm_glob_norm_Tpcpr.conf <- confint(lm_glob_norm_Tpcpr , level = 0.90)
yy.glob_norm_Tipic <- mean(meanSES.INF_glob.norm_Tipic, na.rm = T)
yy.glob_norm_Ticir <- mean(meanSES.INF_glob.norm_Ticir, na.rm = T)
yy.glob_norm_Tpcpr <- mean(meanSES.INF_glob.norm_Tpcpr, na.rm = T)
param_B_glob_norm_Tipic <- exp( (yy.glob_norm_Tipic - lm_glob_norm_Tipic.conf [1, 2]) / 
                                  lm_glob_norm_Tipic.conf [2, 2] )
param_B_glob_norm_Ticir <- exp( (yy.glob_norm_Ticir - lm_glob_norm_Ticir.conf [1, 2]) / 
                                  lm_glob_norm_Ticir.conf [2, 2] )
param_B_glob_norm_Tpcpr <- exp( (yy.glob_norm_Tpcpr - lm_glob_norm_Tpcpr.conf [1, 2]) / 
                                  lm_glob_norm_Tpcpr.conf [2, 2] )

lm_loc_norm_Tipic <- lm(meanSES.4loc.norm_Tipic ~ log(init_param.loc))
lm_loc_norm_Tipic.conf <- confint(lm_loc_norm_Tipic, level = 0.90)
lm_loc_norm_Ticir <- lm(meanSES.4loc.norm_Ticir ~ log(init_param.loc))
lm_loc_norm_Ticir.conf <- confint(lm_loc_norm_Ticir, level = 0.90)
lm_loc_norm_Tpcpr <- lm(meanSES.4loc.norm_Tpcpr ~ log(init_param.loc))
lm_loc_norm_Tpcpr.conf <- confint(lm_loc_norm_Tpcpr, level = 0.90)
yy.loc_norm_Tipic <- mean(SES.inf.MEAN.norm_Tipic, na.rm = T)
yy.loc_norm_Ticir <- mean(SES.inf.MEAN.norm_Ticir, na.rm = T)
yy.loc_norm_Tpcpr <- mean(SES.inf.MEAN.norm_Tpcpr, na.rm = T)
param_B_loc_norm_Tipic <- exp( (yy.loc_norm_Tipic - lm_loc_norm_Tipic.conf [1, 2]) / 
                                  lm_loc_norm_Tipic.conf [2, 2] )
param_B_loc_norm_Ticir <- exp( (yy.loc_norm_Ticir - lm_loc_norm_Ticir.conf [1, 2]) / 
                                  lm_loc_norm_Ticir.conf [2, 2] )
param_B_loc_norm_Tpcpr <- exp( (yy.loc_norm_Tpcpr - lm_loc_norm_Tpcpr.conf [1, 2]) / 
                                  lm_loc_norm_Tpcpr.conf [2, 2] )

# trait b
lm_glob_uni_Tipic <- lm(meanSES.4glob.uni_Tipic ~ log(init_param))
lm_glob_uni_Tipic.conf <- confint(lm_glob_uni_Tipic , level = 0.90)
lm_glob_uni_Ticir <- lm(meanSES.4glob.uni_Ticir ~ log(init_param))
lm_glob_uni_Ticir.conf <- confint(lm_glob_uni_Ticir , level = 0.90)
lm_glob_uni_Tpcpr <- lm(meanSES.4glob.uni_Tpcpr ~ log(init_param))
lm_glob_uni_Tpcpr.conf <- confint(lm_glob_uni_Tpcpr , level = 0.90)
yy.glob_uni_Tipic <- mean(meanSES.INF_glob.uni_Tipic, na.rm = T)
yy.glob_uni_Ticir <- mean(meanSES.INF_glob.uni_Ticir, na.rm = T)
yy.glob_uni_Tpcpr <- mean(meanSES.INF_glob.uni_Tpcpr, na.rm = T)
param_B_glob_uni_Tipic <- exp( (yy.glob_uni_Tipic - lm_glob_uni_Tipic.conf [1, 2]) / 
                                  lm_glob_uni_Tipic.conf [2, 2] )
param_B_glob_uni_Ticir <- exp( (yy.glob_uni_Ticir - lm_glob_uni_Ticir.conf [1, 2]) / 
                                  lm_glob_uni_Ticir.conf [2, 2] )
param_B_glob_uni_Tpcpr <- exp( (yy.glob_uni_Tpcpr - lm_glob_uni_Tpcpr.conf [1, 2]) / 
                                  lm_glob_uni_Tpcpr.conf [2, 2] )

lm_loc_uni_Tipic <- lm(meanSES.4loc.uni_Tipic ~ log(init_param.loc))
lm_loc_uni_Tipic.conf <- confint(lm_loc_uni_Tipic, level = 0.90)
lm_loc_uni_Ticir <- lm(meanSES.4loc.uni_Ticir ~ log(init_param.loc))
lm_loc_uni_Ticir.conf <- confint(lm_loc_uni_Ticir, level = 0.90)
lm_loc_uni_Tpcpr <- lm(meanSES.4loc.uni_Tpcpr ~ log(init_param.loc))
lm_loc_uni_Tpcpr.conf <- confint(lm_loc_uni_Tpcpr, level = 0.90)
yy.loc_uni_Tipic <- mean(SES.inf.MEAN.uni_Tipic, na.rm = T)
yy.loc_uni_Ticir <- mean(SES.inf.MEAN.uni_Ticir, na.rm = T)
yy.loc_uni_Tpcpr <- mean(SES.inf.MEAN.uni_Tpcpr, na.rm = T)
param_B_loc_uni_Tipic <- exp( (yy.loc_uni_Tipic - lm_loc_uni_Tipic.conf [1, 2]) / 
                                  lm_loc_uni_Tipic.conf [2, 2] )
param_B_loc_uni_Ticir <- exp( (yy.loc_uni_Ticir - lm_loc_uni_Ticir.conf [1, 2]) / 
                                  lm_loc_uni_Ticir.conf [2, 2] )
param_B_loc_uni_Tpcpr <- exp( (yy.loc_uni_Tpcpr - lm_loc_uni_Tpcpr.conf [1, 2]) / 
                                  lm_loc_uni_Tpcpr.conf [2, 2] )

@

For the analysis with both internal and external filter we only present the type II error using the initial parameter ratio allowing a beta-error $<0.05$.  

\begin{table}[h!]
\begin{center}
\caption{Initial parameter ratio allowing beta-error $<0.05$ for T-statistics under both external and internal filtering}
\begin{tabular}{|c|c|c|c|m{6cm}|}
\hline
Traits & Indices & Average between communities? & Initial parameter ratio$ \tabularnewline
\hline \hline \hline
\multirow{6}{*}{Trait a (normal)} & \multirow{2}{*}{$T_{IP.IC}$} & no (local) & \Sexpr{round(param_B_loc_norm_Tipic, 3)} \tabularnewline
\cline{3-4} 
 & & yes (global) & \Sexpr{round(param_B_glob_norm_Tipic, 3)} \tabularnewline
\cline{2-4} 
 & \multirow{2}{*}{$T_{IC.IR}$} & no (local) & \Sexpr{round(param_B_loc_norm_Ticir, 3)} \tabularnewline
\cline{3-4} 
 & & yes (global) & \Sexpr{round(param_B_glob_norm_Ticir, 3)} \tabularnewline
\cline{2-4} 
 & \multirow{2}{*}{$T_{PC.PR}$} & no (local) & \Sexpr{round(param_B_loc_norm_Tpcpr, 3)} \tabularnewline
\cline{3-4}
 & & yes (global)& \Sexpr{round(param_B_glob_norm_Tpcpr, 3)} \tabularnewline

\hline \hline \hline

\multirow{6}{*}{Trait b (uniform)} & \multirow{2}{*}{$T_{IP.IC}$} & no (local) & \Sexpr{round(param_B_loc_uni_Tipic, 3)} \tabularnewline
\cline{3-4}
 & & yes (global) &  \Sexpr{round(param_B_glob_uni_Tipic, 3)} \tabularnewline
\cline{2-4} 
 & \multirow{2}{*}{$T_{IC.IR}$} & no (local) & \Sexpr{round(param_B_loc_uni_Ticir, 3)} \tabularnewline
\cline{3-4} 
 & & yes (global) &  \Sexpr{round(param_B_glob_uni_Ticir, 3)} \tabularnewline
\cline{2-4} 
 & \multirow{2}{*}{$T_{PC.PR}$} & no (local) & \Sexpr{round(param_B_loc_uni_Tpcpr, 3)} \tabularnewline
\cline{3-4} 
 & & yes (global)&  \Sexpr{round(param_B_glob_uni_Tpcpr, 3)} \tabularnewline
\hline 
\end{tabular}
\end{center}
\end{table}























\cleardoublepage

\section{Test of variance decomposition functions}
 
In addition to the \texttt{cati} vignette that test this function on the Darwin finch data, we test the behavior of the function \texttt{partvar} and \texttt{decompCTRE} by building two toy models associated to each functions.
 
 \subsection{Behavior of the function \texttt{partvar}}

First to test the behavior of the \texttt{partvar} function we assemble the same data as in the test of the T-statistics. 
1000 individuals belonging to 20 species occuring in 10 communities. But here we define the trait value for one individual as the addition of three values, each one draw in a normal distribution of mean 0 and standard error 1: (i) a value depending on the species the individual belong to, (ii) a value depending on the community the individual belong to and (iii) a independent value measuring the individual variance.

<<Toy_model_2, results = 'hide'>>= 
nperm <- npermut

sdlog = 1.5
#Ten communities named A, B, C ... J
com <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J") 
#Twenty species sp1, sp2, sp3, ... sp20
sp <- paste("sp", seq(1:20), sep = "")

res.partvar_toymodel <- list()
for(n in 1:nperm){#for each permutation
 
 # Draw communities using lognormal distribution of abundances 
 # 100 individuals by populations
 ex.sp5 <- c()
 ex.com5 <- matrix(0, nrow = 10, ncol = 20)
 for(i in 1: 10){
 ex.com.interm <- table(sample(sp, size = 100, prob = rlnorm(20, 0, sdlog), replace = T))
 ex.com5[i, sp%in% names(ex.com.interm)] <- ex.com.interm
 ex.sp5 <- c(ex.sp5, rep(sp, times = ex.com5[i,]))
 }

 
 x1 <- c()
 ex.sp5 <- as.factor(ex.sp5)
 for(s in 1:20){
 x1[ex.sp5 == levels(ex.sp5)[s]] <- rnorm(1)
 }
 
 ex.indplot5 <- sort(as.factor(rep(com, 100)))
 x2 <- c()
 x3 <- c()
 for(c in 1:10){
 x2[ex.indplot5 == levels(ex.indplot5 )[c]] <- rnorm(1)
 }
 X <- rnorm(1000) + x1 + x2
 
 res.partvar_toymodel[[n]] <- partvar(X, factors = cbind(sites = ex.indplot5, 
               species = ex.sp5))
}

@

Now we can plot the result as the density of the three component of variation in individual traits distributions. 
We are waiting for a mean of approximately 0.33 for each component in view of our model.

<<Partvar_plot, fig.width = 6, fig.height = 6, fig.cap = "Variance partitioning accross nested scales: each colored lines represent the density of permutations results (sites in blue, species in orange and the remaining variance in brown). Points represent the mean and segments the standard deviation. Vertical line figure the value of 0.33.">>= 
res.simu.partvar_toymodel <- lapply(res.partvar_toymodel, function (x) x[, 1])
res.simu.partvar_toymodel <- t(matrix(unlist(res.simu.partvar_toymodel), nrow = 3))
colnames(res.simu.partvar_toymodel) <- c("sites", "species", "within")
col.funk <- funky.col(3)

plot(density(res.simu.partvar_toymodel[, 3]), col = col.funk[3], 
  pch = 16, xlim = c(0, 0.9), lwd = 2)
lines(density(res.simu.partvar_toymodel[, 1]), col = col.funk[1], lwd = 2)
lines(density(res.simu.partvar_toymodel[, 2]), col = col.funk[2], lwd = 2)
abline(v = 0.33)
points(apply(res.simu.partvar_toymodel, 2, mean), 
   c(max(density(res.simu.partvar_toymodel[, 1])$y)/2, 
   max(density(res.simu.partvar_toymodel[, 2])$y)/2,
   max(density(res.simu.partvar_toymodel[, 3])$y)/2),
   col = col.funk)
segments(apply(res.simu.partvar_toymodel, 2, mean) - apply(res.simu.partvar_toymodel, 2, sd), 
   c(max(density(res.simu.partvar_toymodel[, 1])$y)/2, 
   max(density(res.simu.partvar_toymodel[, 2])$y)/2,
   max(density(res.simu.partvar_toymodel[, 3])$y)/2),
   apply(res.simu.partvar_toymodel, 2, mean) + apply(res.simu.partvar_toymodel, 2, sd),
   c(max(density(res.simu.partvar_toymodel[, 1])$y)/2, 
   max(density(res.simu.partvar_toymodel[, 2])$y)/2,
   max(density(res.simu.partvar_toymodel[, 3])$y)/2),
   col = col.funk)
legend(0.6, 4, legend = c("sites", "species", "within"), fill = col.funk)
text(0.33, 0.5, pos = 4, "0.33")
@

The mean contribution of each component is close to 0.33. Consequently the function \texttt{partvar} doesn't show apparent dysfunction.

\subsection{Behavior of the function \texttt{decompCTRE}}

To test the function \texttt{decompCTRE}, we adopt the same model but we add a new step to control the strength of the turnover in defining the community weighted mean.
We define several value of turnover strength by deleting individuals from the data set if there their species-components trait and their community-component trait are to different. To be more precise, when \texttt{turnover\_strength} = 1, we delete all individual whose the square of the species value minus the community value is superior o one. 

<<decompCTRE_simu, results = 'hide'>>= 
sdlog = 1.5
turnover_strength <- rep(c(0.01, 0.1, 0.2, 0.5, 1, 2, 3.5, 5, 7.5, 10, 12.5, 15), 
                         N_repet_Param)
nperm <- length(turnover_strength)
res.decompCTRE_toymodel <- list()
for(n in 1:nperm){#for each permutation
 
 # Draw communities using lognormal distribution of abundances 
 # 100 individuals by populations
 ex.sp5 <- c()
 ex.com5 <- matrix(0, nrow = 10, ncol = 20)
 for(i in 1: 10){
 ex.com.interm <- table(sample(sp, size = 100, prob = rlnorm(20, 0, sdlog), replace = T))
 ex.com5[i, sp%in% names(ex.com.interm)] <- ex.com.interm
 ex.sp5 <- c(ex.sp5, rep(sp, times = ex.com5[i,]))
 }

 
 x1 <- c()
 ex.sp5 <- as.factor(ex.sp5)
 for(s in 1:20){
 x1[ex.sp5 == levels(ex.sp5)[s]] <- rnorm(1)
 }
 
 ex.indplot5 <- sort(as.factor(rep(com, 100)))
 x2 <- c()
 for(c in 1:10){
 x2[ex.indplot5 == levels(ex.indplot5)[c]] <- rnorm(1)
 }
 
 X <- rnorm(1000) + x1 + x2
 
 #We delete the individual whose species values and communities values are to different
 #For this we use the argument turnover_strength
 X2 <- X[(x1-x2)^2 < turnover_strength[n]] 
 ex.sp5.bis <- ex.sp5[(x1-x2)^2 < turnover_strength[n]] 
 ex.indplot5.bis <- ex.indplot5[(x1-x2)^2 < turnover_strength[n]] 
 
 res.decompCTRE_toymodel[[n]] <- decompCTRE(traits = cbind(X2, X2), sp = ex.sp5.bis, 
            ind.plot = ex.indplot5.bis)
}#End of simulations
@
Now we can plot the relation between the modeled strength of the turnover and the resulting contribution of turnover from the function \texttt{decompCTRE} (Fig. \ref{fig:decompCTRE_plot1}).

<<decompCTRE_plot1, fig.height = 3, fig.cap = "Decomposition of the variation in community trait composition for two contrasted cases: on the left almost all the variation is due to turnover wheras on the rigth case intraspecific variation explain most of the variation.">>= 
par(mfrow=c(1, 2))
plot(res.decompCTRE_toymodel[[1]]$X2)
plot(res.decompCTRE_toymodel[[n]]$X2)
par(mfrow=c(1, 1))
@

<<decompCTRE_plot2, fig.width = 6, fig.height = 5, fig.cap = "Modeled against obtained turnover contribution in community trait variance">>= 
res.simu.decompCTRE_toymodel <- unlist(lapply(res.decompCTRE_toymodel, function(x) 
                                              x$X2$RelSumSq[1]))
plot(res.simu.decompCTRE_toymodel, -turnover_strength, pch = 16, col = rgb(0, 0, 0, 0.5),
     ylab = "Strength of the turnover (maximum strength = 0)",
     xlab = "Turnover relative contribution to community mean traits")
@

The correlation between the modeled strength of the turnover and the turnover relative contribution result is very high. Consequently the function \texttt{decompCTRE} doesn't show apparent dysfunction (Fig. \ref{fig:decompCTRE_plot2}).

\cleardoublepage


\section{Summary}
\label{sect:summary}

\subsection{Type I error}

Table \ref{tab:Alpha-errors_for_T-stats} summarize the alpha error for T-statistics. The three global \footnote{one indice for all the dataset} T-statistics are very robust 
regardless of the distribution of the trait (alpha error ranging from \Sexpr{min(c(alpha1, alpha2, alpha3, alpha4, alpha5, alpha6), na.rm=T)} to \Sexpr{max(c(alpha1, alpha2, alpha3, alpha4, alpha5, alpha6), na.rm=T)}). Local \footnote{one indice for each community of the dataset} T-statistics present lower but nevertheless satifactory alpha-error with a maximum of \Sexpr{nbre_alpha_error_norm_loc_Tpcpr} for $T_{PC/PR}$ on a trait normally distributed. We therefore recommand to use $T_{IC/IR}$ to detect external filtering and more generally to prefer global T-statistics which are more robust and more powerfull (see the next section).


\subsection{Type II error}


\begin{table}[h!]
\begin{center}
\caption{Summary of initial parameter ratio allowing beta-error $<0.05$ for global T-statistics}
\begin{tabular}{|c|c|>{\centering}m{3cm}|>{\centering}m{3cm}|>{\centering}m{3cm}|}
\hline
Traits & Indices & Initial parameter ratio with internal filtering & Initial parameter ratio with external filtering & Initial parameter ratio with internal and external filtering \tabularnewline
\hline \hline \hline

\multirow{3}{*}{Trait a (normal)} & $T_{IP.IC}$ & \Sexpr{round(param_beta0.05_Tipic.norm, 2)} & \cellcolor{ligthgray}  & \Sexpr{round(param_B_glob_norm_Tipic, 2)}\tabularnewline
\cline{2-5} 
 & $T_{IC.IR}$ & \cellcolor{ligthgray} & \Sexpr{round(param_beta0.05_Ticir.norm, 2)} &  \Sexpr{round(param_B_glob_norm_Ticir, 2)} \tabularnewline
\cline{2-5}
 & $T_{PC.PR}$ & \cellcolor{ligthgray} & \Sexpr{round(param_beta0.05_Tpcpr.norm, 2)} &  \Sexpr{round(param_B_glob_norm_Tpcpr, 2)} \tabularnewline

\hline \hline \hline


Traits & Indices & Initial parameter ratio with internal filtering & Initial parameter ratio with external filtering & Initial parameter ratio with internal and external filtering \tabularnewline
\hline \hline \hline

\multirow{3}{*}{Trait b (uniform)} & $T_{IP.IC}$ & \Sexpr{round(param_beta0.05_Tipic.uni, 2)} & \cellcolor{ligthgray} & \Sexpr{round(param_B_glob_uni_Tipic, 2)}\tabularnewline
\cline{2-5} 
 & $T_{IC.IR}$ & \cellcolor{ligthgray} & \Sexpr{round(param_beta0.05_Ticir.uni, 2)} &  \Sexpr{round(param_B_glob_uni_Ticir, 2)} \tabularnewline
\cline{2-5}
 & $T_{PC.PR}$ & \cellcolor{ligthgray} & \Sexpr{round(param_beta0.05_Tpcpr.uni, 2)} &  \Sexpr{round(param_B_glob_uni_Tpcpr, 2)} \tabularnewline


\hline 
\end{tabular}
\end{center}
\end{table}








\section*{Conclusion}
\addcontentsline{toc}{subsection}{Conclusion}

\section*{References}
\addcontentsline{toc}{subsection}{References}
May RM, Mac Arthur RH (1972) Niche overlap as a function of environmental variability. Proceedings of the National Academy of Sciences 69: 1109-1113.
\\

Violle C, Enquist BJ, McGill BJ, Jiang L, Albert CH, et al. (2012) The return of the variance: intraspecific variability in community ecology. Trends in Ecology & Evolution 27: 244-252.


\listoffigures % table des figures
\listoftables % table des tableaux


\end{document}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

